    <!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="Nemocdz">
		<meta name="description" content="Blog Description">
		<meta name="generator" content="Hugo 0.25.1" />
		<title>AFNetworking的漂亮细节 &middot; Nemocdz&#39;s Blog</title>
		<link rel="shortcut icon" href="https://nemocdz.github.io/My-blog/images/favicon.ico">
		<link rel="stylesheet" href="https://nemocdz.github.io/My-blog/css/style.css">
		<link rel="stylesheet" href="https://nemocdz.github.io/My-blog/css/highlight.css">
		

		
		<link rel="stylesheet" href="https://nemocdz.github.io/My-blog/css/monosocialiconsfont.css">
		

		
		<link href="https://nemocdz.github.io/My-blog/index.xml" rel="alternate" type="application/rss+xml" title="Nemocdz&#39;s Blog" />
		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://nemocdz.github.io/My-blog/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://nemocdz.github.io/My-blog/post'>Archive</a>
	<a href='https://nemocdz.github.io/My-blog/tags'>Tags</a>
	<a href='https://nemocdz.github.io/My-blog/about'>About</a>

	

	
	<a class="cta" href="https://nemocdz.github.io/My-blog/index.xml">RSS</a>
	
</nav>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        AFNetworking的漂亮细节
                    </h1>
                    <h2 class="headline">
                    Aug 16, 2017 03:31
                    · 3530 words
                    · 8 minutes read
                      <span class="tags">
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<h3 id="写在开头">写在开头</h3>

<p>最近重读了AFNetworking源码，发现很多以前读不懂，也不知道为啥这么写的代码慢慢读懂了。过程中被AFNetworking作者的对细节，舒服，整洁的追求所折服。把一些个人觉得写的漂亮的用法总结下来，本文不在于探讨AFNetworking源码的具体业余实现，尽量从代码本身和设计角度进行总结（源码解析推荐<a href="http://www.jianshu.com/p/856f0e26279d">AFNetworking到底做了什么？</a>这篇文章）。</p>

<h4 id="1-dispatch-once方法声明c语言变量方法">1.Dispatch_once方法声明C语言变量方法</h4>

<p>感觉很像OC的protery的getter方法，一种C语言懒加载的感觉，static修饰符意味只在该编译单元可见（对应OC就是.m文件），配合单例，只会被执行一次。类似于<code>if(!object)</code>的感觉。</p>

<p>如下面例子创建了一个queue的方法，调用后返回是同一个变量。</p>

<pre><code class="language-c">static dispatch_queue_t url_session_manager_creation_queue() {
    static dispatch_queue_t af_url_session_manager_creation_queue;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL);
    });

    return af_url_session_manager_creation_queue;
}
</code></pre>

<h4 id="2-使用反射机制来确定keypath">2.使用反射机制来确定KeyPath</h4>

<p>在KVO中，我们一般会观察通过一个属性，而@property其实是一个语法糖，属性=ivar（实例对象）+setter方法+getter方法。而getter方法名就是属性d的名字。利用OC中的反射机制<code>NSStringFromSelector</code>方法获取属性的getter方法的字符串，其实就是属性的KeyPath。这样的KeyPath不容易写错，也容易跳转去看属性的定义。</p>

<pre><code class="language-objective-c"> [progress addObserver:self
            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))
                      options:NSKeyValueObservingOptionNew
                      context:NULL];
</code></pre>

<h4 id="3-用-unused修饰符修饰不用的delegate中的变量">3.用__unused修饰符修饰不用的Delegate中的变量</h4>

<p>一般协议delegate声明时，会把delegate弱持有者作为第一个参数传入delegate方法中，可是有时候delegate的实现者并不关心或不区分delegate对象是谁持有的。</p>

<pre><code class="language-objective-c">- (void)URLSession:(__unused NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error{
    //......
}
</code></pre>

<h4 id="4-避开cocoa类族的坑">4.避开Cocoa类族的坑</h4>

<p>在Foudation框架中，某些类其实是类族，比如NSArray，生成的某一个NSArray对象实际上可能是NSArray的子类。所以用Method Swizzling的去Hook一些系统类方法的时候，要注意某些类实际上是子类，甚至不同系统版本继承链和方法实现都不一样（不一定调用了父类的同名方法）。在AFURLSessionManager中为了Hook系统的NSURLSessionTask的resume和suspend的方法实现中加上通知。由于NSURLSessionTask是一个类族，且iOS7和iOS8上Task类的继承链不同，于是有了以下严谨的代码。</p>

<pre><code class="language-objective-c">if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) {
        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];//先构建NSURLSession
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;
        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];//再通过session对象构建一个task对象
#pragma clang diagnostic pop
        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));//获取要交换的方法的实现指针
        Class currentClass = [localDataTask class];//获取真正的子类
        
        while (class_getInstanceMethod(currentClass, @selector(resume))) //检查是否实现需要交换的方法
        {
            Class superClass = [currentClass superclass];
            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));//获取实现指针
            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));//获取父类的实现指针
            if (classResumeIMP != superclassResumeIMP &amp;&amp;
                originalAFResumeIMP != classResumeIMP) {//如果实现和父类不一样且实现不一样
                [self swizzleResumeAndSuspendMethodForClass:currentClass];
            }
            currentClass = [currentClass superclass];//获取父类继续调用
        }
        
        [localDataTask cancel];
        [session finishTasksAndInvalidate];
}
</code></pre>

<h4 id="5-增加方法到类中再进行method-swizzling">5.增加方法到类中再进行Method Swizzling</h4>

<p>同时为了避免直接换带来多次交换把原来方法弄乱的问题，是先将需要换的方法add到需要替换类中（相当于生成一个副本），然后让那个类里面的副本方法去交换，也就是不影响原来拥有这个方法的类里的方法。</p>

<pre><code class="language-objective-c">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass {
    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));
    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));

    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) {
        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));
    }

    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) {
        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));
    }
}
</code></pre>

<h4 id="6-用gcd的同步方法来封装代码块">6.用GCD的同步方法来封装代码块</h4>

<p>iOS8以下<code>dataTaskWithRequest</code>是生成的task时是并发执行的，造成taskIdentifer偶发不唯一，解决办法是使这个方法串行执行，同时用Dispatch_sync等待结果返回。调用时封装了一个C方法。</p>

<pre><code class="language-objective-c"> url_session_manager_create_task_safely(^{
        downloadTask = [self.session downloadTaskWithRequest:request];
  });
</code></pre>

<pre><code class="language-objective-c">static dispatch_queue_t url_session_manager_creation_queue() {
    static dispatch_queue_t af_url_session_manager_creation_queue;
    static dispatch_once_t onceToken;
 	//创建一个串行队列，只创建一次
    dispatch_once(&amp;onceToken, ^{
        af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL);
    });
    return af_url_session_manager_creation_queue;
}

static void url_session_manager_create_task_safely(dispatch_block_t block) {
    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) {
      	//iOS8以下则调用，同步等待结果
        dispatch_sync(url_session_manager_creation_queue(), block);
    } else {
        block();
    }
}
</code></pre>

<h4 id="7-重写respondstoselector更改delegate实现的判断依据">7.重写respondsToSelector更改Delegate实现的判断依据</h4>

<p>AFNetworking内部的AFURLSessionManager将所有NSURLSessionDelegate的方法都接管了并转换成外界Set进来的Block实现，其中有一些转换并没有做任何处理，单纯转换成Block。所以是否响应这个Delegate方法其实是block是否存在，于是内部就重写了respondsToSelector。</p>

<pre><code class="language-objective-c">- (BOOL)respondsToSelector:(SEL)selector {
    if (selector == @selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)) {
        return self.taskWillPerformHTTPRedirection != nil;
    } else if (selector == @selector(URLSession:dataTask:didReceiveResponse:completionHandler:)) {
        return self.dataTaskDidReceiveResponse != nil;
    } else if (selector == @selector(URLSession:dataTask:willCacheResponse:completionHandler:)) {
        return self.dataTaskWillCacheResponse != nil;
    } else if (selector == @selector(URLSessionDidFinishEventsForBackgroundURLSession:)) {
        return self.didFinishEventsForBackgroundURLSession != nil;
    }

    return [[self class] instancesRespondToSelector:selector];
}
</code></pre>

<h4 id="8-dynamic关键字实现默认调用父类setter-getter">8.@dynamic关键字实现默认调用父类setter&amp;getter</h4>

<p>当子类重新声明一个父类的属性时，其实默认合成了setter&amp;getter并覆盖了父类的默认实现。对于想子类声明属性却希望默认调用父类属性的setter&amp;getter，可以用@dynamic关键字。</p>

<p>AFHTTPSessionManger是AFURLSessionManger的子类，也声明了securityPolicy属性并重写其setter方法，但希望getter方法调用父类的。</p>

<pre><code class="language-objective-c">@dynamic securityPolicy;

- (void)setSecurityPolicy:(AFSecurityPolicy *)securityPolicy {
    if (securityPolicy.SSLPinningMode != AFSSLPinningModeNone &amp;&amp; ![self.baseURL.scheme isEqualToString:@&quot;https&quot;]) {
        NSString *pinningMode = @&quot;Unknown Pinning Mode&quot;;
        switch (securityPolicy.SSLPinningMode) {
            case AFSSLPinningModeNone:        pinningMode = @&quot;AFSSLPinningModeNone&quot;; break;
            case AFSSLPinningModeCertificate: pinningMode = @&quot;AFSSLPinningModeCertificate&quot;; break;
            case AFSSLPinningModePublicKey:   pinningMode = @&quot;AFSSLPinningModePublicKey&quot;; break;
        }
        NSString *reason = [NSString stringWithFormat:@&quot;A security policy configured with `%@` can only be applied on a manager with a secure base URL (i.e. https)&quot;, pinningMode];
        @throw [NSException exceptionWithName:@&quot;Invalid Security Policy&quot; reason:reason userInfo:nil];
    }
    [super setSecurityPolicy:securityPolicy];
}
</code></pre>

<h4 id="9-kvo用context区分父类与子类">9.KVO用Context区分父类与子类</h4>

<p>KVO中的Api<code>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context</code>总是在dealloc方法中配合<code>- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context</code>成对使用来移除观察者。但如果父类和子类都同时观察一个keyPath，那么容易导致addObserver和removeObserver的个数不匹配（子类未调用父类的addObserver方法但调用了父类的dealloc），导致重复调用remove同一个keyPath而Crash。所以加上context作为类别唯一标识才是比较安全的做法。</p>

<pre><code class="language-objective-c">- (void)dealloc {
    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
        if ([self respondsToSelector:NSSelectorFromString(keyPath)]) {
            [self removeObserver:self forKeyPath:keyPath context:AFHTTPRequestSerializerObserverContext];
        }
    }
}
</code></pre>

<h4 id="10-用gcd实现同步属性">10.用GCD实现同步属性</h4>

<p>实现某个属性值setter方法和getter方法的同步除了用NSLock或者@synchronized关键字加锁外，可以使用在并发队列里setter配合dispatch_barrier_async加上getter配合dispatch_sync实现。这样读取是同步并发的，写入是在没有读取都完成后，同步执行的，并且性能比加锁更好。AFHTTPRequestSerializer里的HTTPHeaderField就是这样的。</p>

<pre><code class="language-objective-c">- (void)setValue:(NSString *)value
forHTTPHeaderField:(NSString *)field
{
    dispatch_barrier_async(self.requestHeaderModificationQueue, ^{
        [self.mutableHTTPRequestHeaders setValue:value forKey:field];
    });
}

- (NSString *)valueForHTTPHeaderField:(NSString *)field {
    NSString __block *value;
    dispatch_sync(self.requestHeaderModificationQueue, ^{
        value = [self.mutableHTTPRequestHeaders valueForKey:field];
    });
    return value;
}
</code></pre>

<h4 id="11-对nsstream类的操作">11.对NSStream类的操作</h4>

<p>AFHTTPRequestSerizlizer进行Multipart协议支持时，使用了NSStream对象。</p>

<p>一般使用方法是</p>

<pre><code class="language-objective-c">//创建流对象
NSInputStream *stream = [[NSInputStream alloc] initWithData:[NSData data]];

//放入Runloop中
[stream scheduleInRunLoop:NSRunLoop.currentRunLoop forMode:NSDefaultRunLoopMode];

//打开流
[stream open];

//.......

//从Runloop中移除
[stream removeFromRunLoop:NSRunLoop.currentRunLoop forMode:NSDefaultRunLoopMode];

//关闭流
[stream close];
</code></pre>

<p>结果发现AFNetworking在析构NSStream时，没有调用removeFromRunLoop，仅仅调用了close，我一开始还以为漏了，结果后来书写Demo验证发现其引用计数的变化时如下的。</p>

<pre><code class="language-objective-c">//放入Runloop中-----引用计数+2
[stream scheduleInRunLoop:NSRunLoop.currentRunLoop forMode:NSDefaultRunLoopMode];

//打开流-----引用计数不变
[stream open];

//.......

//从Runloop中移除-----引用计数-2
[stream removeFromRunLoop:NSRunLoop.currentRunLoop forMode:NSDefaultRunLoopMode];

//关闭流-----引用计数-2
[stream close];
</code></pre>

<p>也就是说open和close对引用计数的影响不是一对的，从一定程度上解释只调用close也可以达到removeFromRunLoop的原因，个人猜测close和removeFromRunLoop调用任意一个都可以。顺便提一句AFMultipartBodyStream还对NSStreamStauts一些只读属性改成读写的，并自定义了所有流的方法。</p>

<h4 id="12-category中实现属性懒加载">12.Category中实现属性懒加载</h4>

<p>使用了OC的关联对象，先获取判断是否为空，不然就生成并关联上。</p>

<pre><code class="language-objective-c">- (AFRefreshControlNotificationObserver *)af_notificationObserver {
    AFRefreshControlNotificationObserver *notificationObserver = objc_getAssociatedObject(self, @selector(af_notificationObserver));
    if (notificationObserver == nil) {
        notificationObserver = [[AFRefreshControlNotificationObserver alloc] initWithActivityRefreshControl:self];
        objc_setAssociatedObject(self, @selector(af_notificationObserver), notificationObserver, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    return notificationObserver;
}
</code></pre>

<h4 id="13-头文件明确声明nonull和nullable">13.头文件明确声明Nonull和Nullable</h4>

<p>自从支持Swift后，和Swift中的?和!对应，OC引入了Nonull和Nullable关键字，当然对每个方法参数和属性声明关键字是很大工作量的，这时我们可以用一对系统宏包含在最前和最后，中间的默认关键字就是Nonull了，这时候针对Nullable的参数或属性进行补充就可以了。</p>

<pre><code class="language-objective-c">//.h
NS_ASSUME_NONNULL_BEGIN

//...
@property (nonatomic, strong, nullable) id &lt;AFImageRequestCache&gt; imageCache;
//...

NS_ASSUME_NONNULL_END
</code></pre>

<h3 id="最后">最后</h3>

<p>AFNetworking是一份写得十分严谨漂亮的源码，其中对KVO&amp;KVC，GCD，Block，关联对象的运用十分巧妙且准确，同时接口的封装，代码的划分也很恰当。阅读之后对于代码规范又有了新的理解。</p>

                </section>
            </article>

            

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    
    <a class="symbol" href="https://www.facebook.com/nemocdz">
        circlefacebook
    </a>
    
    <a class="symbol" href="https://github.com/Nemocdz">
        circlegithub
    </a>
    
    <a class="symbol" href="https://twitter.com/Nemocdz">
        circletwitterbird
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2017 <i class="fa fa-heart" aria-hidden="true"></i> Nemocdz
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://nemocdz.github.io/My-blog/js/jquery-2.2.4.min.js"></script>
<script src="https://nemocdz.github.io/My-blog/js/main.js"></script>
<script src="https://nemocdz.github.io/My-blog/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
