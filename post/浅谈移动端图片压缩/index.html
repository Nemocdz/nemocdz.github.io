<!DOCTYPE html>
<html lang="zh-cn">
<head>

  <meta charset="utf-8" />

  
  <title>浅谈移动端图片压缩(iOS &amp; Android)</title>

  
  




  
  <meta name="author" content="Nemocdz" />
  <meta name="description" content="[TOC]
在 App 中，如果分享、发布、上传功能涉及到图片，必不可少会对图片进行一定程度的压缩。笔者最近在公司项目中恰好重构了双端（iOS&amp;amp;Android）的图片压缩模块。本文会非常基础的讲解一些图片压缩的方式和思路。
" />

  
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@Nemocdz" />
    <meta name="twitter:title" content="浅谈移动端图片压缩(iOS &amp; Android)" />
    <meta name="twitter:description" content="[TOC]
在 App 中，如果分享、发布、上传功能涉及到图片，必不可少会对图片进行一定程度的压缩。笔者最近在公司项目中恰好重构了双端（iOS&amp;amp;Android）的图片压缩模块。本文会非常基础的讲解一些图片压缩的方式和思路。
" />
    <meta name="twitter:image" content="https://nemocdz.github.io/img/avatar.jpg" />
  




<meta name="generator" content="Hugo 0.55.6" />


<link rel="canonical" href="https://nemocdz.github.io/post/%E6%B5%85%E8%B0%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/" />
<link rel="alternative" href="https://nemocdz.github.io/index.xml" title="Nemocdz&#39;s Blog" type="application/atom+xml" />


<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />


<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />
<meta name="google-site-verification" content="ew6In8Dh7Hjg0Eozgh-VpZHVNe83XRZVOGwQSSAbrfw" />
<meta name="msvalidate.01" content="42FB873348345E1A196D7F595FFB7126" />
<meta name="baidu-site-verification" content="iVpH4VhHBT" />
<meta name="sogou_site_verification" content="YPqjjJgiSh" />
<meta name="360-site-verification" content="699b5919746ff9568f6484fcec29f386" />


<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Nemocdz&#39;s Blog" />
<meta name="msapplication-tooltip" content="Nemocdz&#39;s Blog" />
<meta name='msapplication-navbutton-color' content="#5fbf5e" />
<meta name="msapplication-TileColor" content="#5fbf5e" />
<meta name="msapplication-TileImage" content="/img/tile-image-windows.png" />
<link rel="icon" href="https://nemocdz.github.io/img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="https://nemocdz.github.io/img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://nemocdz.github.io/img/favicon-32x32.png" />
<link rel="icon" sizes="192x192" href="https://nemocdz.github.io/img/touch-icon-android.png" />
<link rel="apple-touch-icon" href="https://nemocdz.github.io/img/touch-icon-apple.png" />
<link rel="mask-icon" href="https://nemocdz.github.io/img/safari-pinned-tab.svg" color="#5fbf5e" />



<link rel="stylesheet" href="//cdn.bootcss.com/video.js/6.2.1/video-js.min.css" />

<link rel="stylesheet" href="https://nemocdz.github.io/css/bundle.css" />


  
  <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdn.bootcss.com/video.js/6.2.1/ie8/videojs-ie8.min.js"></script>
  <![endif]-->

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/2014.01.31/classList.min.js"></script>
  <![endif]-->


<script src="//cdn.bootcss.com/object-fit-images/3.2.3/ofi.min.js"></script>


<script src="//cdn.bootcss.com/smooth-scroll/12.1.0/js/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
        
        <a title="Go to comments" class="to-comment" href="#disqus_thread"><span class="icon icon-comment"></span></a>
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="https://nemocdz.github.io/img/avatar.png" alt="Avatar">
  
  <h2 class="title">Nemocdz&#39;s Blog</h2>
  
  <p class="subtitle">iOS&amp;Android Dev</p>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item  is-active"><a href="https://nemocdz.github.io/">首页</a></li>
      
        <li class="menu-item "><a href="https://nemocdz.github.io/about/">关于</a></li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list">

      
      <li class="social-item">
        <a href="mailto:nemocdz@gmail.com" title="Email"><span class="icon icon-email"></span></a>
      </li>

      
      <li class="social-item">
        <a href="//github.com/Nemocdz" title="GitHub"><span class="icon icon-github"></span></a>
      </li>

      <li class="social-item">
        <a href="//twitter.com/Nemocdz" title="Twitter"><span class="icon icon-twitter"></span></a>
      </li>

      

      

      <li class="social-item">
        <a href="//www.instagram.com/Nemocdz" title="Instagram"><span class="icon icon-instagram"></span></a>
      </li>

      

      

      

      

      

      

      

      

      

      <li class="social-item">
        <a href="//weibo.com/Nemocdz" title="Weibo"><span class="icon icon-weibo"></span></a>
      </li>

      <li class="social-item">
        <a href="https://nemocdz.github.io/img/qrcode.jpg" title="Wechat"><span class="icon icon-wechat"></span></a>
      </li>

      

      <li class="social-item">
        <a href="//www.zhihu.com/people/nemocdz" title="Zhihu"><span class="icon icon-zhihu"></span></a>
      </li>

      

      

      <li class="social-item">
        <a href="https://nemocdz.github.io/index.xml"><span class="icon icon-rss" title="RSS"></span></a>
      </li>

    </ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">浅谈移动端图片压缩(iOS &amp; Android)</h1>
      <p class="post-meta">@Nemocdz · Jan 20, 2019 · 13 min read</p>
    </header>
    <article class="post-content"><p>[TOC]</p>

<p>在 App 中，如果分享、发布、上传功能涉及到图片，必不可少会对图片进行一定程度的压缩。笔者最近在公司项目中恰好重构了双端（iOS&amp;Android）的图片压缩模块。本文会非常基础的讲解一些图片压缩的方式和思路。</p>

<h2 id="图片格式基础">图片格式基础</h2>

<h3 id="点阵图-矢量图">点阵图&amp;矢量图</h3>

<ul>
<li>点阵图：也叫位图。用像素为单位，像素保存颜色信息，排列像素实现显示。</li>
<li>矢量图：记录元素形状和颜色的算法，显示时展示算法运算的结果。</li>
</ul>

<h3 id="颜色">颜色</h3>

<p>表示颜色时，有两种形式，一种为索引色（Index Color），一种为直接色（Direct Color）</p>

<ul>
<li>索引色：用一个数字索引代表一种颜色，在图像信息中存储数字到颜色的映射关系表（调色盘 Palette）。每个像素保存该像素颜色对应的数字索引。一般调色盘只能存储有限种类的颜色，通常为 256 种。所以每个像素的数字占用 1 字节（8 bit）大小。</li>
<li>直接色：用四个数字来代表一种颜色，数字分别对应颜色中红色，绿色，蓝色，透明度（RGBA）。每个像素保存这四个纬度的信息来代表该像素的颜色。根据色彩深度（每个像素存储颜色信息的 bit 数不同），最多可以支持的颜色种类也不同，常见的有 8 位（R3+G3+B2）、16 位（R5+G6+B5）、24 位（R8+G8+B8）、32 位（A8+R8+G8+B8）。所以每个像素占用 1~4 字节大小。</li>
</ul>

<h3 id="移动端常用图片格式">移动端常用图片格式</h3>

<p>图片格式中一般分为静态图和动态图</p>

<h4 id="静态图">静态图</h4>

<ul>
<li><p>JPG：是支持 JPEG（ 一种有损压缩方法）标准中最常用的图片格式。采用点阵图。常见的是使用 24 位的颜色深度的直接色（不支持透明）。</p></li>

<li><p>PNG：是支持无损压缩的图片格式。采用点阵图。PNG 有 5 种颜色选项：索引色、灰度、灰度透明、真彩色（24 位直接色）、真彩色透明（32 位直接色）。</p></li>

<li><p>WebP：是同时支持有损压缩和无所压缩的的图片格式。采用点阵图。支持 32 位直接色。移动端支持情况如下：</p></li>
</ul>

<table>
<thead>
<tr>
<th align="center">系统</th>
<th align="center">原生</th>
<th align="center">WebView</th>
<th align="center">浏览器</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">iOS</td>
<td align="center">第三方库支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>

<tr>
<td align="center">Android</td>
<td align="center">4.3 后支持完整功能</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
</tbody>
</table>

<h4 id="动态图">动态图</h4>

<ul>
<li><p>GIF：是支持无损压缩的图片格式。采用点阵图。使用索引色，并有 1 位透明度通道（透明与否）。</p></li>

<li><p>APNG：基于 PNG 格式扩展的格式，加入动态图支持。采用点阵图。使用 32 位直接色。但没有被官方 PNG 接纳。移动端支持情况如下：</p></li>
</ul>

<table>
<thead>
<tr>
<th align="center">系统</th>
<th align="center">原生</th>
<th align="center">WebView</th>
<th align="center">浏览器</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">iOS</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>

<tr>
<td align="center">Android</td>
<td align="center">第三方库支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
</tbody>
</table>

<ul>
<li>Animated Webp：Webp 的动图形式，实际上是文件中打包了多个单帧 Webp，在 libwebp 0.4 后开始支持。移动端支持情况如下：</li>
</ul>

<table>
<thead>
<tr>
<th align="center">系统</th>
<th align="center">原生</th>
<th align="center">WebView</th>
<th align="center">系统浏览器</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">iOS</td>
<td align="center">第三方库支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>

<tr>
<td align="center">Android</td>
<td align="center">第三方库支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
</tbody>
</table>

<p>而由于一般项目需要兼容三端（iOS、Android、Web 的关系），最简单就是支持 JPG、PNG、GIF 这三种通用的格式。所以本文暂不讨论其余图片格式的压缩。</p>

<h3 id="移动端系统图片处理架构">移动端系统图片处理架构</h3>

<p>根据我的了解，画了一下 iOS&amp;Android 图片处理架构。iOS 这边，也是可以直接调用底层一点的框架的。</p>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fz5abubavwj31pg0u0gsk.jpg" alt="屏幕快照 2019-01-13 下午9.37.00" /></p>

<h2 id="ios-的-imageio">iOS 的 ImageIO</h2>

<p>本文 iOS 端处理图片主要用 ImageIO 框架，使用的原因主要是静态图动态图 API 调用保持一致，且不会因为 UIImage 转换时会丢失一部分数据的信息。</p>

<p>ImageIO 主要提供了图片编解码功能，封装了一套 C 语言接口。在 Swift 中不需要对 C 对象进行内存管理，会比 Objective-C 中使用方便不少，但 api 结果返回都是 Optional（实际上非空），需要用 <code>guard</code>/<code>if</code>，或者 <code>!</code>进行转换。</p>

<h3 id="解码">解码</h3>

<h4 id="1-创建-cgimagesource">1. 创建 CGImageSource</h4>

<p><code>CGImageSource</code> 相当于 ImageIO 数据来源的抽象类。通用的使用方式 <code>CGImageSourceCreateWithDataProvider:</code> 需要提供一个 DataProvider，可以指定文件、URL、Data 等输入。也有通过传入 CFData 来进行创建的便捷方法 <code>CGImageSourceCreateWithData:</code>。方法的第二个参数 options 传入一个字典进行配置。根据 Apple 在 WWDC 2018 上的 <a href="https://developer.apple.com/videos/play/wwdc2018/219/">Image and Graphics Best Practices</a> 上的例子，当不需要解码仅需要创建 <code>CGImageSource</code> 的时候，应该将 <code>kCGImageSourceShouldCache</code> 设为 false。</p>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fz7jhd3o50j30yg0fnwlf.jpg" alt="11994763-6f25c32bd4d3b427" /></p>

<h4 id="2-解码得到-cgimage">2. 解码得到 CGImage</h4>

<p>用 <code>CGImageSourceCreateImageAtIndex:</code> 或者 <code>CGImageSourceCreateThumbnailAtIndex:</code> 来获取生成的 <code>CGImage</code>，这里参数的 Index 就是第几帧图片，静态图传入 0 即可。</p>

<h3 id="编码">编码</h3>

<h4 id="1-创建-cgimagedestination">1. 创建 CGImageDestination</h4>

<p><code>CGImageDestination</code> 相当于 ImageIO 数据输出的抽象类。通用的使用方式 <code>CGImageDestinationCreateWithDataConsumer:</code> 需要提供一个 DataConsumer，可以置顶 URL、Data 等输入。也有通过传入 CFData 来进行创建的便捷方法 <code>CGImageDestinationCreateWithData:</code>，输出会写入到传入的 Data 中。方法还需要提供图片类型，图片帧数。</p>

<h4 id="2-添加-cgimage">2. 添加 CGImage</h4>

<p>添加 <code>CGImage</code> 使用 <code>CGImageDestinationAddImage:</code> 方法，动图的话，按顺序多次调用就行了。</p>

<p>而且还有一个特别的 <code>CGImageDestinationAddImageFromSource:</code> 方法，添加的其实是一个 <code>CGImageSource</code>，有什么用呢，通过 options 参数，达到改变图像设置的作用。比如改变 JPG 的压缩参数，用上这个功能后，就不需要转换成更顶层的对象（比如 <code>UIImage</code>），减少了转换时的编解码的损耗，达到性能更优的目的。</p>

<h4 id="3-进行编码">3. 进行编码</h4>

<p>调用 <code>CGImageDestinationFinalize:</code> ，表示开始编码，完成后会返回一个 <code>Bool</code> 值，并将数据写入 <code>CGImageDestination</code> 提供的 DataConsumer 中。</p>

<h2 id="压缩思路分析">压缩思路分析</h2>

<p>位图占用的空间大小，其实就是像素数量 x 单像素占用空间 x 帧数。所以减小图片空间大小，其实就从这三个方向下手。其中单像素占用空间，在直接色的情况下，主要和色彩深度相关。在实际项目中，改变色彩深度会导致图片颜色和原图没有保持完全一致，笔者并不建议对色彩深度进行更改。而像素数量就是平时非常常用的图片分辨率缩放。除此之外，JPG 格式还有特有的通过指定压缩系数来进行有损压缩。</p>

<ul>
<li>JPG：压缩系数 + 分辨率缩放 + 色彩深度降低</li>
<li>PNG： 分辨率缩放 + 降低色彩深度</li>
<li>GIF：减少帧数 + 每帧分辨率缩放 + 减小调色盘</li>
</ul>

<h3 id="判断图片格式">判断图片格式</h3>

<p>后缀扩展名来判断其实并不保险，真实的判断方式应该是通过文件头里的信息进行判断。</p>

<table>
<thead>
<tr>
<th>JPG</th>
<th>PNG</th>
<th>GIF</th>
</tr>
</thead>

<tbody>
<tr>
<td>开头：FF D8  + 结尾：FF D9</td>
<td>89 50 4E 47 0D 0A 1A 0A</td>
<td>47 49 46 38 <sup>39</sup>&frasl;<sub>37</sub> 61</td>
</tr>
</tbody>
</table>

<p>简单判断用前三个字节来判断</p>

<h4 id="ios">iOS</h4>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">Data</span><span class="p">{</span>   
    <span class="kd">enum</span> <span class="nc">ImageFormat</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">jpg</span><span class="p">,</span> <span class="n">png</span><span class="p">,</span> <span class="n">gif</span><span class="p">,</span> <span class="n">unknown</span>
    <span class="p">}</span>
    
    <span class="kd">var</span> <span class="nv">imageFormat</span><span class="p">:</span><span class="n">ImageFormat</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">headerData</span> <span class="p">=</span> <span class="p">[</span><span class="nb">UInt8</span><span class="p">](</span><span class="n">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">copyBytes</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="p">&amp;</span><span class="n">headerData</span><span class="p">,</span> <span class="n">from</span><span class="p">:(</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="mi">3</span><span class="p">))</span>
        <span class="kd">let</span> <span class="nv">hexString</span> <span class="p">=</span> <span class="n">headerData</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">+</span> <span class="nb">String</span><span class="p">((</span><span class="nv">$1</span><span class="p">&amp;</span><span class="mh">0xFF</span><span class="p">),</span> <span class="n">radix</span><span class="p">:</span><span class="mi">16</span><span class="p">)</span> <span class="p">}.</span><span class="n">uppercased</span><span class="p">()</span>
        <span class="kd">var</span> <span class="nv">imageFormat</span> <span class="p">=</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">unknown</span>
        <span class="k">switch</span> <span class="n">hexString</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">&#34;FFD8FF&#34;</span><span class="p">:</span> <span class="n">imageFormat</span> <span class="p">=</span> <span class="p">.</span><span class="n">jpg</span>
        <span class="k">case</span> <span class="s">&#34;89504E&#34;</span><span class="p">:</span> <span class="n">imageFormat</span> <span class="p">=</span> <span class="p">.</span><span class="n">png</span>
        <span class="k">case</span> <span class="s">&#34;474946&#34;</span><span class="p">:</span> <span class="n">imageFormat</span> <span class="p">=</span> <span class="p">.</span><span class="n">gif</span>
        <span class="k">default</span><span class="p">:</span><span class="k">break</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">imageFormat</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>iOS 中除了可以用文件头信息以外，还可以将 Data 转成 <code>CGImageSource</code>，然后用 <code>CGImageSourceGetType</code> 这个 API，这样会获取到 ImageIO 框架支持的图片格式的的 UTI 标识的字符串。对应的标识符常量定义在 MobileCoreServices 框架下的 <code>UTCoreTypes</code> 中。</p>

<table>
<thead>
<tr>
<th>字符串常量</th>
<th>UTI 格式（字符串原始值）</th>
</tr>
</thead>

<tbody>
<tr>
<td>kUTTypePNG</td>
<td>public.png</td>
</tr>

<tr>
<td>kUTTypeJPEG</td>
<td>public.jpeg</td>
</tr>

<tr>
<td>kUTTypeGIF</td>
<td>com.compuserve.gif</td>
</tr>
</tbody>
</table>

<h4 id="andorid">Andorid</h4>
<div class="highlight"><pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">enum</span> <span class="k">class</span> <span class="nc">ImageFormat</span><span class="p">{</span>
    <span class="n">JPG</span><span class="p">,</span> <span class="n">PNG</span><span class="p">,</span> <span class="n">GIF</span><span class="p">,</span> <span class="n">UNKNOWN</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">ByteArray</span><span class="p">.</span><span class="n">imageFormat</span><span class="p">():</span> <span class="n">ImageFormat</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">headerData</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="m">0.</span><span class="p">.</span><span class="m">2</span><span class="p">)</span>
    <span class="k">val</span> <span class="py">hexString</span> <span class="p">=</span> <span class="n">headerData</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="n">StringBuilder</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span> <span class="p">{</span> <span class="n">result</span><span class="p">,</span> <span class="n">byte</span> <span class="p">-&gt;</span> <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">byte</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span> <span class="n">and</span> <span class="m">0xFF</span><span class="p">).</span><span class="n">toString</span><span class="p">(</span><span class="m">16</span><span class="p">)</span> <span class="p">)</span> <span class="p">}.</span><span class="n">toString</span><span class="p">().</span><span class="n">toUpperCase</span><span class="p">()</span>
    <span class="k">var</span> <span class="py">imageFormat</span> <span class="p">=</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">UNKNOWN</span>
    <span class="k">when</span> <span class="p">(</span><span class="n">hexString</span><span class="p">)</span> <span class="p">{</span>
        <span class="s">&#34;FFD8FF&#34;</span> <span class="p">-&gt;</span> <span class="p">{</span>
            <span class="n">imageFormat</span> <span class="p">=</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">JPG</span>
        <span class="p">}</span>
        <span class="s">&#34;89504E&#34;</span> <span class="p">-&gt;</span> <span class="p">{</span>
            <span class="n">imageFormat</span> <span class="p">=</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">PNG</span>
        <span class="p">}</span>
        <span class="s">&#34;474946&#34;</span> <span class="p">-&gt;</span> <span class="p">{</span>
            <span class="n">imageFormat</span> <span class="p">=</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">GIF</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">imageFormat</span>
<span class="p">}</span></code></pre></div>
<h3 id="色彩深度改变">色彩深度改变</h3>

<p>实际上，减少深度一般也就是从 32 位减少至 16 位，但颜色的改变并一定能让产品、用户、设计接受，所以笔者在压缩过程并没有实际使用改变色彩深度的方法，仅仅研究了做法。</p>

<h4 id="ios-1">iOS</h4>

<p>在 iOS 中，改变色彩深度，原生的 <code>CGImage</code> 库中，没有简单的方法。需要自己设置参数，重新生成 <code>CGImage</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">init</span><span class="p">?(</span><span class="n">width</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">bitsPerComponent</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">bitsPerPixel</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">bytesPerRow</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">space</span><span class="p">:</span> <span class="n">CGColorSpace</span><span class="p">,</span> <span class="n">bitmapInfo</span><span class="p">:</span> <span class="n">CGBitmapInfo</span><span class="p">,</span> <span class="n">provider</span><span class="p">:</span> <span class="n">CGDataProvider</span><span class="p">,</span> <span class="n">decode</span><span class="p">:</span> <span class="nb">UnsafePointer</span><span class="p">&lt;</span><span class="n">CGFloat</span><span class="o">&gt;?</span><span class="p">,</span> <span class="n">shouldInterpolate</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="n">CGColorRenderingIntent</span><span class="p">)</span></code></pre></div>
<ul>
<li>bitsPerComponent 每个通道占用位数</li>
<li>bitsPerPixel 每个像素占用位数，相当于所有通道加起来的位数，也就是色彩深度</li>
<li>bytesPerRow 传入 0 即可，系统会自动计算</li>
<li>space 色彩空间</li>
<li>bitmapInfo 这个是一个很重要的东西，其中常用的信息有 <code>CGImageAlphaInfo</code>，代表是否有透明通道，透明通道在前还是后面（ARGB 还是 RGBA），是否有浮点数（floatComponents），<code>CGImageByteOrderInfo</code>，代表字节顺序，采用大端还是小端，以及数据单位宽度，iOS 一般采用 32 位小端模式，一般用 orderDefault 就好。</li>
</ul>

<p>那么对于常用的色彩深度，就可以用这些参数的组合来完成。同时笔者在查看更底层的 vImage 框架的 <code>vImage_CGImageFormat</code> 结构体时（CGImage 底层也是使用 vImage，具体可查看 Accelerate 框架 vImage 库的 vImage_Utilities 文件），发现了 Apple 的注释，里面也包含了常用的色彩深度用的参数。</p>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fz7kziqcaij32q40t6n94.jpg" alt="屏幕快照 2019-01-15 下午9.16.40" /></p>

<p>这一块为了和 Android 保持一致，笔者封装了 Android 常用的色彩深度参数对应的枚举值。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">ColorConfig</span><span class="p">{</span>
    <span class="k">case</span> <span class="n">alpha8</span>
    <span class="k">case</span> <span class="n">rgb565</span>
    <span class="k">case</span> <span class="n">argb8888</span>
    <span class="k">case</span> <span class="n">rgbaF16</span>
    <span class="k">case</span> <span class="n">unknown</span> <span class="c1">// 其余色彩配置</span>
<span class="p">}</span></code></pre></div>
<p><code>CGBitmapInfo</code> 由于是 Optional Set，可以封装用到的属性的便捷方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">CGBitmapInfo</span> <span class="p">{</span>
    <span class="kd">init</span><span class="p">(</span><span class="kc">_</span> <span class="n">alphaInfo</span><span class="p">:</span><span class="n">CGImageAlphaInfo</span><span class="p">,</span> <span class="kc">_</span> <span class="n">isFloatComponents</span><span class="p">:</span><span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">array</span> <span class="p">=</span> <span class="p">[</span>
            <span class="n">CGBitmapInfo</span><span class="p">(</span><span class="n">rawValue</span><span class="p">:</span> <span class="n">alphaInfo</span><span class="p">.</span><span class="n">rawValue</span><span class="p">),</span>
            <span class="n">CGBitmapInfo</span><span class="p">(</span><span class="n">rawValue</span><span class="p">:</span> <span class="n">CGImageByteOrderInfo</span><span class="p">.</span><span class="n">orderDefault</span><span class="p">.</span><span class="n">rawValue</span><span class="p">)</span>
        <span class="p">]</span>
        
        <span class="k">if</span> <span class="n">isFloatComponents</span> <span class="p">{</span>
            <span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(.</span><span class="n">floatComponents</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="kc">self</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>那么 ColorConfig 对应的 <code>CGImage</code> 参数也可以对应起来了。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">ColorConfig</span><span class="p">{</span>
    <span class="kd">struct</span> <span class="nc">CGImageConfig</span><span class="p">{</span>
        <span class="kd">let</span> <span class="nv">bitsPerComponent</span><span class="p">:</span><span class="nb">Int</span>
        <span class="kd">let</span> <span class="nv">bitsPerPixel</span><span class="p">:</span><span class="nb">Int</span>
        <span class="kd">let</span> <span class="nv">bitmapInfo</span><span class="p">:</span> <span class="n">CGBitmapInfo</span>
    <span class="p">}</span>
    
    <span class="kd">var</span> <span class="nv">imageConfig</span><span class="p">:</span><span class="n">CGImageConfig</span><span class="p">?{</span>
        <span class="k">switch</span> <span class="kc">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">alpha8</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CGImageConfig</span><span class="p">(</span><span class="n">bitsPerComponent</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">bitsPerPixel</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">bitmapInfo</span><span class="p">:</span> <span class="n">CGBitmapInfo</span><span class="p">(.</span><span class="n">alphaOnly</span><span class="p">))</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">rgb565</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CGImageConfig</span><span class="p">(</span><span class="n">bitsPerComponent</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">bitsPerPixel</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="n">bitmapInfo</span><span class="p">:</span> <span class="n">CGBitmapInfo</span><span class="p">(.</span><span class="n">noneSkipFirst</span><span class="p">))</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">argb8888</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CGImageConfig</span><span class="p">(</span><span class="n">bitsPerComponent</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">bitsPerPixel</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="n">bitmapInfo</span><span class="p">:</span> <span class="n">CGBitmapInfo</span><span class="p">(.</span><span class="n">premultipliedFirst</span><span class="p">))</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">rgbaF16</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CGImageConfig</span><span class="p">(</span><span class="n">bitsPerComponent</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="n">bitsPerPixel</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span> <span class="n">bitmapInfo</span><span class="p">:</span> <span class="n">CGBitmapInfo</span><span class="p">(.</span><span class="n">premultipliedLast</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">unknown</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>反过来，判断 <code>CGImage</code> 的 ColorConfig 的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">CGImage</span><span class="p">{</span>
    <span class="kd">var</span> <span class="nv">colorConfig</span><span class="p">:</span><span class="n">ColorConfig</span><span class="p">{</span>
        <span class="k">if</span> <span class="n">isColorConfig</span><span class="p">(.</span><span class="n">alpha8</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">.</span><span class="n">alpha8</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">isColorConfig</span><span class="p">(.</span><span class="n">rgb565</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">.</span><span class="n">rgb565</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">isColorConfig</span><span class="p">(.</span><span class="n">argb8888</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">.</span><span class="n">argb8888</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">isColorConfig</span><span class="p">(.</span><span class="n">rgbaF16</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">.</span><span class="n">rgbaF16</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">.</span><span class="n">unknown</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">isColorConfig</span><span class="p">(</span><span class="kc">_</span> <span class="n">colorConfig</span><span class="p">:</span><span class="n">ColorConfig</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span><span class="p">{</span>
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">imageConfig</span> <span class="p">=</span> <span class="n">colorConfig</span><span class="p">.</span><span class="n">imageConfig</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">bitsPerComponent</span> <span class="p">==</span> <span class="n">imageConfig</span><span class="p">.</span><span class="n">bitsPerComponent</span> <span class="o">&amp;&amp;</span>
            <span class="n">bitsPerPixel</span> <span class="p">==</span> <span class="n">imageConfig</span><span class="p">.</span><span class="n">bitsPerPixel</span> <span class="o">&amp;&amp;</span>
            <span class="n">imageConfig</span><span class="p">.</span><span class="n">bitmapInfo</span><span class="p">.</span><span class="bp">contains</span><span class="p">(</span><span class="n">CGBitmapInfo</span><span class="p">(</span><span class="n">alphaInfo</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
            <span class="n">imageConfig</span><span class="p">.</span><span class="n">bitmapInfo</span><span class="p">.</span><span class="bp">contains</span><span class="p">(.</span><span class="n">floatComponents</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>对外封装的 Api，也就是直接介绍的 ImageIO 的使用步骤，只是参数不一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift">    <span class="c1">/// 改变图片到指定的色彩配置</span>
    <span class="c1">///</span>
    <span class="c1">/// - Parameters:</span>
    <span class="c1">///   - rawData: 原始图片数据</span>
    <span class="c1">///   - config: 色彩配置</span>
    <span class="c1">/// - Returns: 处理后数据</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">changeColorWithImageData</span><span class="p">(</span><span class="kc">_</span> <span class="n">rawData</span><span class="p">:</span><span class="n">Data</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span><span class="n">ColorConfig</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Data</span><span class="p">?{</span>
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">imageConfig</span> <span class="p">=</span> <span class="n">config</span><span class="p">.</span><span class="n">imageConfig</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">rawData</span>
        <span class="p">}</span>
    
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">imageSource</span> <span class="p">=</span> <span class="n">CGImageSourceCreateWithData</span><span class="p">(</span><span class="n">rawData</span> <span class="k">as</span> <span class="n">CFData</span><span class="p">,</span> <span class="p">[</span><span class="n">kCGImageSourceShouldCache</span><span class="p">:</span> <span class="kc">false</span><span class="p">]</span> <span class="k">as</span> <span class="n">CFDictionary</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">writeData</span> <span class="p">=</span> <span class="n">CFDataCreateMutable</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">imageType</span> <span class="p">=</span> <span class="n">CGImageSourceGetType</span><span class="p">(</span><span class="n">imageSource</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">imageDestination</span> <span class="p">=</span> <span class="n">CGImageDestinationCreateWithData</span><span class="p">(</span><span class="n">writeData</span><span class="p">,</span> <span class="n">imageType</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">rawDataProvider</span> <span class="p">=</span> <span class="n">CGDataProvider</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">rawData</span> <span class="k">as</span> <span class="n">CFData</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">imageFrame</span> <span class="p">=</span> <span class="n">CGImage</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="nb">Int</span><span class="p">(</span><span class="n">rawData</span><span class="p">.</span><span class="n">imageSize</span><span class="p">.</span><span class="n">width</span><span class="p">),</span>
                                     <span class="n">height</span><span class="p">:</span> <span class="nb">Int</span><span class="p">(</span><span class="n">rawData</span><span class="p">.</span><span class="n">imageSize</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
                                     <span class="n">bitsPerComponent</span><span class="p">:</span> <span class="n">imageConfig</span><span class="p">.</span><span class="n">bitsPerComponent</span><span class="p">,</span>
                                     <span class="n">bitsPerPixel</span><span class="p">:</span> <span class="n">imageConfig</span><span class="p">.</span><span class="n">bitsPerPixel</span><span class="p">,</span>
                                     <span class="n">bytesPerRow</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                     <span class="n">space</span><span class="p">:</span> <span class="n">CGColorSpaceCreateDeviceRGB</span><span class="p">(),</span>
                                     <span class="n">bitmapInfo</span><span class="p">:</span> <span class="n">imageConfig</span><span class="p">.</span><span class="n">bitmapInfo</span><span class="p">,</span>
                                     <span class="n">provider</span><span class="p">:</span> <span class="n">rawDataProvider</span><span class="p">,</span>
                                     <span class="n">decode</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
                                     <span class="n">shouldInterpolate</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
                                     <span class="n">intent</span><span class="p">:</span> <span class="p">.</span><span class="n">defaultIntent</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
                                        <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="n">CGImageDestinationAddImage</span><span class="p">(</span><span class="n">imageDestination</span><span class="p">,</span> <span class="n">imageFrame</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">guard</span> <span class="n">CGImageDestinationFinalize</span><span class="p">(</span><span class="n">imageDestination</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">writeData</span> <span class="k">as</span> <span class="n">Data</span>
    <span class="p">}</span>
    
    
    <span class="c1">/// 获取图片的色彩配置</span>
    <span class="c1">///</span>
    <span class="c1">/// - Parameter rawData: 原始图片数据</span>
    <span class="c1">/// - Returns: 色彩配置</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">getColorConfigWithImageData</span><span class="p">(</span><span class="kc">_</span> <span class="n">rawData</span><span class="p">:</span><span class="n">Data</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">ColorConfig</span><span class="p">{</span>
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">imageSource</span> <span class="p">=</span> <span class="n">CGImageSourceCreateWithData</span><span class="p">(</span><span class="n">rawData</span> <span class="k">as</span> <span class="n">CFData</span><span class="p">,</span> <span class="p">[</span><span class="n">kCGImageSourceShouldCache</span><span class="p">:</span> <span class="kc">false</span><span class="p">]</span> <span class="k">as</span> <span class="n">CFDictionary</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">imageFrame</span> <span class="p">=</span> <span class="n">CGImageSourceCreateImageAtIndex</span><span class="p">(</span><span class="n">imageSource</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">.</span><span class="n">unknown</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">imageFrame</span><span class="p">.</span><span class="n">colorConfig</span>
    <span class="p">}</span></code></pre></div>
<h4 id="android">Android</h4>

<p>对于 Android 来说，其原生的 Bitmap 库有相当方便的转换色彩深度的方法，只需要传入 Config 就好。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Bitmap</span> <span class="nf">copy</span><span class="o">(</span><span class="n">Config</span> <span class="n">config</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isMutable</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">checkRecycled</span><span class="o">(</span><span class="s">&#34;Can&#39;t copy a recycled bitmap&#34;</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">config</span> <span class="o">==</span> <span class="n">Config</span><span class="o">.</span><span class="na">HARDWARE</span> <span class="o">&amp;&amp;</span> <span class="n">isMutable</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Hardware bitmaps are always immutable&#34;</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="n">noteHardwareBitmapSlowCall</span><span class="o">();</span>
      <span class="n">Bitmap</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nativeCopy</span><span class="o">(</span><span class="n">mNativePtr</span><span class="o">,</span> <span class="n">config</span><span class="o">.</span><span class="na">nativeInt</span><span class="o">,</span> <span class="n">isMutable</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">b</span><span class="o">.</span><span class="na">setPremultiplied</span><span class="o">(</span><span class="n">mRequestPremultiplied</span><span class="o">);</span>
          <span class="n">b</span><span class="o">.</span><span class="na">mDensity</span> <span class="o">=</span> <span class="n">mDensity</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
<span class="o">}</span></code></pre></div>
<p>iOS 的 <code>CGImage</code> 参数和 Android 的 <code>Bitmap.Config</code> 以及色彩深度对应关系如下表：</p>

<table>
<thead>
<tr>
<th>色彩深度</th>
<th>iOS</th>
<th>Android</th>
</tr>
</thead>

<tbody>
<tr>
<td>8 位灰度（只有透明度）</td>
<td>bitsPerComponent: 8 bitsPerPixel: 8  bitmapInfo: CGImageAlphaInfo.alphaOnly</td>
<td>Bitmap.Config.ALPHA_8</td>
</tr>

<tr>
<td>16 位色（R5+G6+R5）</td>
<td>bitsPerComponent: 5 bitsPerPixel: 16  bitmapInfo: CGImageAlphaInfo.noneSkipFirst</td>
<td>Bitmap.Config.RGB_565</td>
</tr>

<tr>
<td>32 位色（A8+R8+G8+B8）</td>
<td>bitsPerComponent: 8 bitsPerPixel: 32  bitmapInfo: CGImageAlphaInfo.premultipliedFirst</td>
<td>Bitmap.Config.ARGB_8888</td>
</tr>

<tr>
<td>64 位色（R16+G16+B16+A16 但使用半精度减少一半储存空间）用于宽色域或HDR</td>
<td>bitsPerComponent: 16 bitsPerPixel: 64 bitmapInfo: CGImageAlphaInfo.premultipliedLast + .floatComponents</td>
<td>Bitmap.Config.RGBA_F16</td>
</tr>
</tbody>
</table>

<h3 id="jpg-的压缩系数改变">JPG 的压缩系数改变</h3>

<p>JPG 的压缩算法相当复杂，以至于主流使用均是用 <a href="http://libjpeg.sourceforge.net/">libjpeg</a> 这个广泛的库进行编解码（在 Android 7.0 上开始使用性能更好的 <a href="https://libjpeg-turbo.org/">libjpeg-turbo</a>，iOS 则是用 Apple 自己开发未开源的 AppleJPEG）。而在 iOS 和 Android 上，都有 Api 输入压缩系数，来压缩 JPG。但具体压缩系数如何影响压缩大小，笔者并未深究。这里只能简单给出使用方法。</p>

<h4 id="ios-2">iOS</h4>

<p>iOS 里面压缩系数为 0-1 之间的数值，据说 iOS 相册中采用的压缩系数是 0.9。同时，png 不支持有损压缩，所以 <code>kCGImageDestinationLossyCompressionQuality</code> 这个参数是无效。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">static</span> <span class="kd">func</span> <span class="nf">compressImageData</span><span class="p">(</span><span class="kc">_</span> <span class="n">rawData</span><span class="p">:</span><span class="n">Data</span><span class="p">,</span> <span class="n">compression</span><span class="p">:</span><span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Data</span><span class="p">?{</span>
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">imageSource</span> <span class="p">=</span> <span class="n">CGImageSourceCreateWithData</span><span class="p">(</span><span class="n">rawData</span> <span class="k">as</span> <span class="n">CFData</span><span class="p">,</span> <span class="p">[</span><span class="n">kCGImageSourceShouldCache</span><span class="p">:</span> <span class="kc">false</span><span class="p">]</span> <span class="k">as</span> <span class="n">CFDictionary</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">writeData</span> <span class="p">=</span> <span class="n">CFDataCreateMutable</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">imageType</span> <span class="p">=</span> <span class="n">CGImageSourceGetType</span><span class="p">(</span><span class="n">imageSource</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">imageDestination</span> <span class="p">=</span> <span class="n">CGImageDestinationCreateWithData</span><span class="p">(</span><span class="n">writeData</span><span class="p">,</span> <span class="n">imageType</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        
        <span class="kd">let</span> <span class="nv">frameProperties</span> <span class="p">=</span> <span class="p">[</span><span class="n">kCGImageDestinationLossyCompressionQuality</span><span class="p">:</span> <span class="n">compression</span><span class="p">]</span> <span class="k">as</span> <span class="n">CFDictionary</span>
        <span class="n">CGImageDestinationAddImageFromSource</span><span class="p">(</span><span class="n">imageDestination</span><span class="p">,</span> <span class="n">imageSource</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frameProperties</span><span class="p">)</span>
        <span class="k">guard</span> <span class="n">CGImageDestinationFinalize</span><span class="p">(</span><span class="n">imageDestination</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">writeData</span> <span class="k">as</span> <span class="n">Data</span>
    <span class="p">}</span></code></pre></div>
<h4 id="andoid">Andoid</h4>

<p>Andoird 用 Bitmap 自带的接口，并输出到流中。压缩系数是 0-100 之间的数值。这里的参数虽然可以填 <code>Bitmap.CompressFormat.PNG</code>，但当然也是无效的。</p>
<div class="highlight"><pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">val</span> <span class="py">outputStream</span> <span class="p">=</span> <span class="n">ByteArrayOutputStream</span><span class="p">()</span>
<span class="k">val</span> <span class="py">image</span> <span class="p">=</span> <span class="n">BitmapFactory</span><span class="p">.</span><span class="n">decodeByteArray</span><span class="p">(</span><span class="n">rawData</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="n">rawData</span><span class="p">.</span><span class="n">count</span><span class="p">())</span>
<span class="n">image</span><span class="p">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Bitmap</span><span class="p">.</span><span class="n">CompressFormat</span><span class="p">.</span><span class="n">JPEG</span><span class="p">,</span> <span class="n">compression</span><span class="p">,</span> <span class="n">outputStream</span><span class="p">)</span>
<span class="n">resultData</span> <span class="p">=</span> <span class="n">outputStream</span><span class="p">.</span><span class="n">toByteArray</span><span class="p">()</span></code></pre></div>
<h3 id="gif-的压缩">GIF 的压缩</h3>

<p>GIF 压缩上有很多种思路。参考开源项目 <a href="https://github.com/kohler/gifsicle">gifsicle</a> 和 <a href="https://github.com/ImageMagick/ImageMagick">ImageMagick</a> 中的做法，大概有以下几种。</p>

<ol>
<li><p>由于 GIF 支持全局调色盘和局部调色盘，在没有局部调色盘的时候会用放在文件头中的全局调色盘。所以对于颜色变化不大的 GIF，可以将颜色放入全局调色盘中，去除局部调色盘。</p></li>

<li><p>对于颜色较少的 GIF，将调色盘大小减少，比如从 256 种减少到 128 种等。</p></li>
</ol>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fzdbp21oqag305k05ggqc.gif" alt="1490353055438_2367_1490353055781" /></p>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fzdbp9om1dg305k05gjum.gif" alt="1490353098026_7360_1490353098210" /></p>

<ol>
<li>对于背景一致，画面中有一部分元素在变化的 GIF，可以将多个元素和背景分开存储，然后加上如何还原的信息</li>
</ol>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fzdbmaoit6g302s02swe9.gif" alt="b522ac7896b320b4a9ee1eed1034e4fe_articlex" /></p>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fzdbmqdaz2g30fk042jrb.gif" alt="9e9fe93459fe7117909eb27771bdc182_articlex" /></p>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fzdbn0nrthg30fk042747.gif" alt="433b41c29c6a70e64631a3d4c363e468_articlex" /></p>

<ol>
<li>对于背景一致，画面中有一部分元素在动的 GIF，可以和前面一帧比较，将不动的部分透明化</li>
</ol>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fzdbnox1heg303c0283ys.gif" alt="d3c7444d59eed11d98abbb7c4e1da7ec_articlex" /></p>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fzdbnycn68g30eo03e3yu.gif" alt="e50b7f75feebb9bd056bb8dca9964873_articlex" /></p>

<p><img src="https://image-1252104468.cos.ap-guangzhou.myqcloud.com/blog/006tNc79gy1fzdbo6podqg30eo03imxc.gif" alt="704d70c65d22fb240cb5f6f7be5bbf86_articlex" /></p>

<ol>
<li><p>对于帧数很多的 GIF，可以抽取中间部分的帧，减少帧数</p></li>

<li><p>对于每帧分辨率很高的 GIF，将每帧的分辨率减小</p></li>
</ol>

<p>对于动画的 GIF，3、4 是很实用的，因为背景一般是不变的，但对于拍摄的视频转成的 GIF，就没那么实用了，因为存在轻微抖动，很难做到背景不变。但在移动端，除非将 ImageMagick 或者 gifsicle 移植到 iOS&amp;Android 上，要实现前面 4 个方法是比较困难的。笔者这里只实现了抽帧，和每帧分辨率压缩。</p>

<p>至于抽帧的间隔，参考了 <a href="https://cloud.tencent.com/developer/article/1004763">文章</a> 中的数值。</p>

<table>
<thead>
<tr>
<th>帧数</th>
<th>每 x 帧使用 1 帧</th>
</tr>
</thead>

<tbody>
<tr>
<td>&lt;9</td>
<td>x = 2</td>
</tr>

<tr>
<td>9 - 20</td>
<td>x = 3</td>
</tr>

<tr>
<td>21 - 30</td>
<td>x = 4</td>
</tr>

<tr>
<td>31 - 40</td>
<td>x = 5</td>
</tr>

<tr>
<td>&gt;40</td>
<td>x = 6</td>
</tr>
</tbody>
</table>

<p>这里还有一个问题，抽帧的时候，原来的帧可能使用了 3、4 的方法进行压缩过，但还原的时候需要还原成完整的图像帧，再重新编码时，就没有办法再用 3、4 进行优化了。虽然帧减少了，但实际上会将帧还原成未做 3、4 优化的状态，一增一减，压缩的效果就没那么好了（所以这种压缩还是尽量在服务器做）。抽帧后记得将中间被抽取的帧的时间累加在剩下的帧的时间上，不然帧速度就变快了，而且不要用抽取数x帧时间偷懒来计算，因为不一定所有帧的时间是一样的。</p>

<h4 id="ios-3">iOS</h4>

<p>iOS 上的实现比较简单，用 ImageIO 的函数即可实现，性能也比较好。</p>

<p>先定义从 ImageSource 获取每帧的时间的便捷扩展方法，帧时长会存在 <code>kCGImagePropertyGIFUnclampedDelayTime</code> 或者 <code>kCGImagePropertyGIFDelayTime</code> 中，两个 key 不同之处在于后者有最小值的限制，正确的获取方法参考苹果在 WebKit 中的 <a href="https://stackoverflow.com/questions/16964366/delaytime-or-unclampeddelaytime-for-gifs">使用方法</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">CGImageSource</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">frameDurationAtIndex</span><span class="p">(</span><span class="kc">_</span> <span class="n">index</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Double</span><span class="p">{</span>
        <span class="kd">var</span> <span class="nv">frameDuration</span> <span class="p">=</span> <span class="nb">Double</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">frameProperties</span> <span class="p">=</span> <span class="n">CGImageSourceCopyPropertiesAtIndex</span><span class="p">(</span><span class="kc">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="k">as</span><span class="p">?</span> <span class="p">[</span><span class="n">AnyHashable</span><span class="p">:</span><span class="nb">Any</span><span class="p">],</span> <span class="kd">let</span> <span class="nv">gifProperties</span> <span class="p">=</span> <span class="n">frameProperties</span><span class="p">[</span><span class="n">kCGImagePropertyGIFDictionary</span><span class="p">]</span> <span class="k">as</span><span class="p">?</span> <span class="p">[</span><span class="n">AnyHashable</span><span class="p">:</span><span class="nb">Any</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">frameDuration</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">unclampedDuration</span> <span class="p">=</span> <span class="n">gifProperties</span><span class="p">[</span><span class="n">kCGImagePropertyGIFUnclampedDelayTime</span><span class="p">]</span> <span class="k">as</span><span class="p">?</span> <span class="n">NSNumber</span> <span class="p">{</span>
            <span class="n">frameDuration</span> <span class="p">=</span> <span class="n">unclampedDuration</span><span class="p">.</span><span class="n">doubleValue</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="kd">let</span> <span class="nv">clampedDuration</span> <span class="p">=</span> <span class="n">gifProperties</span><span class="p">[</span><span class="n">kCGImagePropertyGIFDelayTime</span><span class="p">]</span> <span class="k">as</span><span class="p">?</span> <span class="n">NSNumber</span> <span class="p">{</span>
                <span class="n">frameDuration</span> <span class="p">=</span> <span class="n">clampedDuration</span><span class="p">.</span><span class="n">doubleValue</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">frameDuration</span> <span class="o">&lt;</span> <span class="mf">0.011</span> <span class="p">{</span>
            <span class="n">frameDuration</span> <span class="p">=</span> <span class="mf">0.1</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">frameDuration</span>
    <span class="p">}</span>
    
    <span class="kd">var</span> <span class="nv">frameDurations</span><span class="p">:[</span><span class="nb">Double</span><span class="p">]{</span>
        <span class="kd">let</span> <span class="nv">frameCount</span> <span class="p">=</span> <span class="n">CGImageSourceGetCount</span><span class="p">(</span><span class="kc">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="n">frameCount</span><span class="p">).</span><span class="bp">map</span><span class="p">{</span> <span class="kc">self</span><span class="p">.</span><span class="n">frameDurationAtIndex</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>先去掉不要的帧，合并帧的时间，再重新生成帧就完成了。注意帧不要被拖得太长，不然体验不好，我这里给的最大值是 200ms。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift">    <span class="c1">/// 同步压缩图片抽取帧数，仅支持 GIF</span>
    <span class="c1">///</span>
    <span class="c1">/// - Parameters:</span>
    <span class="c1">///   - rawData: 原始图片数据</span>
    <span class="c1">///   - sampleCount: 采样频率，比如 3 则每三张用第一张，然后延长时间</span>
    <span class="c1">/// - Returns: 处理后数据</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">compressImageData</span><span class="p">(</span><span class="kc">_</span> <span class="n">rawData</span><span class="p">:</span><span class="n">Data</span><span class="p">,</span> <span class="n">sampleCount</span><span class="p">:</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Data</span><span class="p">?{</span>
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">imageSource</span> <span class="p">=</span> <span class="n">CGImageSourceCreateWithData</span><span class="p">(</span><span class="n">rawData</span> <span class="k">as</span> <span class="n">CFData</span><span class="p">,</span> <span class="p">[</span><span class="n">kCGImageSourceShouldCache</span><span class="p">:</span> <span class="kc">false</span><span class="p">]</span> <span class="k">as</span> <span class="n">CFDictionary</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">writeData</span> <span class="p">=</span> <span class="n">CFDataCreateMutable</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">imageType</span> <span class="p">=</span> <span class="n">CGImageSourceGetType</span><span class="p">(</span><span class="n">imageSource</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        
        <span class="c1">// 计算帧的间隔</span>
        <span class="kd">let</span> <span class="nv">frameDurations</span> <span class="p">=</span> <span class="n">imageSource</span><span class="p">.</span><span class="n">frameDurations</span>
        
        <span class="c1">// 合并帧的时间,最长不可高于 200ms</span>
        <span class="kd">let</span> <span class="nv">mergeFrameDurations</span> <span class="p">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="n">frameDurations</span><span class="p">.</span><span class="bp">count</span><span class="p">).</span><span class="bp">filter</span><span class="p">{</span> <span class="nv">$0</span> <span class="o">%</span> <span class="n">sampleCount</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">}.</span><span class="bp">map</span><span class="p">{</span> <span class="bp">min</span><span class="p">(</span><span class="n">frameDurations</span><span class="p">[</span><span class="nv">$0</span><span class="p">..&lt;</span><span class="bp">min</span><span class="p">(</span><span class="nv">$0</span> <span class="o">+</span> <span class="n">sampleCount</span><span class="p">,</span> <span class="n">frameDurations</span><span class="p">.</span><span class="bp">count</span><span class="p">)].</span><span class="bp">reduce</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">+</span> <span class="nv">$1</span> <span class="p">},</span> <span class="mf">0.2</span><span class="p">)</span> <span class="p">}</span>
        
        <span class="c1">// 抽取帧 每 n 帧使用 1 帧</span>
        <span class="kd">let</span> <span class="nv">sampleImageFrames</span> <span class="p">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="n">frameDurations</span><span class="p">.</span><span class="bp">count</span><span class="p">).</span><span class="bp">filter</span><span class="p">{</span> <span class="nv">$0</span> <span class="o">%</span> <span class="n">sampleCount</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">}.</span><span class="n">compactMap</span><span class="p">{</span> <span class="n">CGImageSourceCreateImageAtIndex</span><span class="p">(</span><span class="n">imageSource</span><span class="p">,</span> <span class="nv">$0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">}</span>
        
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">imageDestination</span> <span class="p">=</span> <span class="n">CGImageDestinationCreateWithData</span><span class="p">(</span><span class="n">writeData</span><span class="p">,</span> <span class="n">imageType</span><span class="p">,</span> <span class="n">sampleImageFrames</span><span class="p">.</span><span class="bp">count</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        
        <span class="c1">// 每一帧图片都进行重新编码</span>
        <span class="n">zip</span><span class="p">(</span><span class="n">sampleImageFrames</span><span class="p">,</span> <span class="n">mergeFrameDurations</span><span class="p">).</span><span class="n">forEach</span><span class="p">{</span>
            <span class="c1">// 设置帧间隔</span>
            <span class="kd">let</span> <span class="nv">frameProperties</span> <span class="p">=</span> <span class="p">[</span><span class="n">kCGImagePropertyGIFDictionary</span> <span class="p">:</span> <span class="p">[</span><span class="n">kCGImagePropertyGIFDelayTime</span><span class="p">:</span> <span class="nv">$1</span><span class="p">,</span> <span class="n">kCGImagePropertyGIFUnclampedDelayTime</span><span class="p">:</span> <span class="nv">$1</span><span class="p">]]</span>
            <span class="n">CGImageDestinationAddImage</span><span class="p">(</span><span class="n">imageDestination</span><span class="p">,</span> <span class="nv">$0</span><span class="p">,</span> <span class="n">frameProperties</span> <span class="k">as</span> <span class="n">CFDictionary</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">guard</span> <span class="n">CGImageDestinationFinalize</span><span class="p">(</span><span class="n">imageDestination</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">writeData</span> <span class="k">as</span> <span class="n">Data</span>
    <span class="p">}</span>
    </code></pre></div>
<p>压缩分辨率也是类似的，每帧按分辨率压缩再重新编码就好。</p>

<h4 id="android-1">Android</h4>

<p>Android 原生对于 GIF 的支持就不怎么友好了，由于笔者 Android 研究不深，暂时先用 <a href="https://github.com/bumptech/glide">Glide</a> 中的 GIF 编解码组件来完成。编码的性能比较一般，比不上 iOS，但除非换用更底层 C++ 库实现的编码库，Java 写的性能都很普通。先用 Gradle 导入 Glide，注意解码器是默认的，但编码器需要另外导入。</p>
<div class="highlight"><pre class="chroma"><code class="language-groovy" data-lang="groovy"><span class="n">api</span> <span class="s1">&#39;com.github.bumptech.glide:glide:4.8.0&#39;</span>
<span class="n">api</span> <span class="s1">&#39;com.github.bumptech.glide:gifencoder-integration:4.8.0&#39;</span></code></pre></div>
<p>抽帧思路和 iOS 一样，只是 Glide 的这个 GIF 解码器没办法按指定的 index 取读取某一帧，只能一帧帧读取，调用 <code>advance</code> 方法往后读取。先从 GIF 读出头部信息，然后在读真正的帧信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-kotlin" data-lang="kotlin">	<span class="cm">/**
</span><span class="cm">     * 返回同步压缩 gif 图片 Byte 数据 [rawData] 的按 [sampleCount] 采样后的 Byte 数据
</span><span class="cm">     */</span>
    <span class="k">private</span> <span class="k">fun</span> <span class="nf">compressGifDataWithSampleCount</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">rawData</span><span class="p">:</span> <span class="n">ByteArray</span><span class="p">,</span> <span class="n">sampleCount</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">ByteArray</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sampleCount</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">rawData</span>
        <span class="p">}</span>
        <span class="k">val</span> <span class="py">gifDecoder</span> <span class="p">=</span> <span class="n">StandardGifDecoder</span><span class="p">(</span><span class="n">GifBitmapProvider</span><span class="p">(</span><span class="n">Glide</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">bitmapPool</span><span class="p">))</span>
        <span class="k">val</span> <span class="py">headerParser</span> <span class="p">=</span> <span class="n">GifHeaderParser</span><span class="p">()</span>
        <span class="n">headerParser</span><span class="p">.</span><span class="n">setData</span><span class="p">(</span><span class="n">rawData</span><span class="p">)</span>
        <span class="k">val</span> <span class="py">header</span> <span class="p">=</span> <span class="n">headerParser</span><span class="p">.</span><span class="n">parseHeader</span><span class="p">()</span>
        <span class="n">gifDecoder</span><span class="p">.</span><span class="n">setData</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">rawData</span><span class="p">)</span>

        <span class="k">val</span> <span class="py">frameCount</span> <span class="p">=</span> <span class="n">gifDecoder</span><span class="p">.</span><span class="n">frameCount</span>

        <span class="c1">// 计算帧的间隔
</span><span class="c1"></span>        <span class="k">val</span> <span class="py">frameDurations</span> <span class="p">=</span> <span class="p">(</span><span class="m">0</span> <span class="n">until</span> <span class="n">frameCount</span><span class="p">).</span><span class="n">map</span> <span class="p">{</span> <span class="n">gifDecoder</span><span class="p">.</span><span class="n">getDelay</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>

        <span class="c1">// 合并帧的时间,最长不可高于 200ms
</span><span class="c1"></span>        <span class="k">val</span> <span class="py">mergeFrameDurations</span> <span class="p">=</span> <span class="p">(</span><span class="m">0</span> <span class="n">until</span> <span class="n">frameCount</span><span class="p">).</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">%</span> <span class="n">sampleCount</span> <span class="p">==</span> <span class="m">0</span> <span class="p">}.</span><span class="n">map</span> <span class="p">{</span>
            <span class="n">min</span><span class="p">(</span>
                <span class="n">frameDurations</span><span class="p">.</span><span class="n">subList</span><span class="p">(</span>
                    <span class="n">it</span><span class="p">,</span>
                    <span class="n">min</span><span class="p">(</span><span class="n">it</span> <span class="p">+</span> <span class="n">sampleCount</span><span class="p">,</span> <span class="n">frameCount</span><span class="p">)</span>
                <span class="p">).</span><span class="n">fold</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">acc</span><span class="p">,</span> <span class="n">duration</span> <span class="p">-&gt;</span> <span class="n">acc</span> <span class="p">+</span> <span class="n">duration</span> <span class="p">},</span> <span class="m">200</span>
            <span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// 抽取帧
</span><span class="c1"></span>        <span class="k">val</span> <span class="py">sampleImageFrames</span> <span class="p">=</span> <span class="p">(</span><span class="m">0</span> <span class="n">until</span> <span class="n">frameCount</span><span class="p">).</span><span class="n">mapNotNull</span> <span class="p">{</span>
            <span class="n">gifDecoder</span><span class="p">.</span><span class="n">advance</span><span class="p">()</span>
            <span class="k">var</span> <span class="py">imageFrame</span><span class="p">:</span> <span class="n">Bitmap</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">%</span> <span class="n">sampleCount</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">imageFrame</span> <span class="p">=</span> <span class="n">gifDecoder</span><span class="p">.</span><span class="n">nextFrame</span>
            <span class="p">}</span>
            <span class="n">imageFrame</span>
        <span class="p">}</span>

        <span class="k">val</span> <span class="py">gifEncoder</span> <span class="p">=</span> <span class="n">AnimatedGifEncoder</span><span class="p">()</span>

        <span class="k">var</span> <span class="py">resultData</span><span class="p">:</span> <span class="n">ByteArray</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>

        <span class="k">try</span> <span class="p">{</span>
            <span class="k">val</span> <span class="py">outputStream</span> <span class="p">=</span> <span class="n">ByteArrayOutputStream</span><span class="p">()</span>
            <span class="n">gifEncoder</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">outputStream</span><span class="p">)</span>
            <span class="n">gifEncoder</span><span class="p">.</span><span class="n">setRepeat</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>

            <span class="c1">// 每一帧图片都进行重新编码
</span><span class="c1"></span>            <span class="n">sampleImageFrames</span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">mergeFrameDurations</span><span class="p">).</span><span class="n">forEach</span> <span class="p">{</span>
                <span class="c1">// 设置帧间隔
</span><span class="c1"></span>                <span class="n">gifEncoder</span><span class="p">.</span><span class="n">setDelay</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">)</span>
                <span class="n">gifEncoder</span><span class="p">.</span><span class="n">addFrame</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
                <span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">recycle</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">gifEncoder</span><span class="p">.</span><span class="n">finish</span><span class="p">()</span>

            <span class="n">resultData</span> <span class="p">=</span> <span class="n">outputStream</span><span class="p">.</span><span class="n">toByteArray</span><span class="p">()</span>
            <span class="n">outputStream</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">IOException</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="n">printStackTrace</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">resultData</span>
    <span class="p">}</span></code></pre></div>
<p>压缩分辨率的时候要注意，分辨率太大编码容易出现 Crash（应该是 OOM），这里设置为 512。</p>
<div class="highlight"><pre class="chroma"><code class="language-kotlin" data-lang="kotlin">    <span class="cm">/**
</span><span class="cm">     * 返回同步压缩 gif 图片 Byte 数据 [rawData] 每一帧长边到 [limitLongWidth] 后的 Byte 数据
</span><span class="cm">     */</span>
    <span class="k">private</span> <span class="k">fun</span> <span class="nf">compressGifDataWithLongWidth</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">rawData</span><span class="p">:</span> <span class="n">ByteArray</span><span class="p">,</span> <span class="n">limitLongWidth</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">ByteArray</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">gifDecoder</span> <span class="p">=</span> <span class="n">StandardGifDecoder</span><span class="p">(</span><span class="n">GifBitmapProvider</span><span class="p">(</span><span class="n">Glide</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">bitmapPool</span><span class="p">))</span>
        <span class="k">val</span> <span class="py">headerParser</span> <span class="p">=</span> <span class="n">GifHeaderParser</span><span class="p">()</span>
        <span class="n">headerParser</span><span class="p">.</span><span class="n">setData</span><span class="p">(</span><span class="n">rawData</span><span class="p">)</span>
        <span class="k">val</span> <span class="py">header</span> <span class="p">=</span> <span class="n">headerParser</span><span class="p">.</span><span class="n">parseHeader</span><span class="p">()</span>
        <span class="n">gifDecoder</span><span class="p">.</span><span class="n">setData</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">rawData</span><span class="p">)</span>
        <span class="k">val</span> <span class="py">frameCount</span> <span class="p">=</span> <span class="n">gifDecoder</span><span class="p">.</span><span class="n">frameCount</span>

        <span class="c1">// 计算帧的间隔
</span><span class="c1"></span>        <span class="k">val</span> <span class="py">frameDurations</span> <span class="p">=</span> <span class="p">(</span><span class="m">0.</span><span class="p">.(</span><span class="n">frameCount</span> <span class="p">-</span> <span class="m">1</span><span class="p">)).</span><span class="n">map</span> <span class="p">{</span> <span class="n">gifDecoder</span><span class="p">.</span><span class="n">getDelay</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>

        <span class="c1">// 计算调整后大小
</span><span class="c1"></span>        <span class="k">val</span> <span class="py">longSideWidth</span> <span class="p">=</span> <span class="n">max</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
        <span class="k">val</span> <span class="py">ratio</span> <span class="p">=</span> <span class="n">limitLongWidth</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">/</span> <span class="n">longSideWidth</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span>
        <span class="k">val</span> <span class="py">resizeWidth</span> <span class="p">=</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">width</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">*</span> <span class="n">ratio</span><span class="p">).</span><span class="n">toInt</span><span class="p">()</span>
        <span class="k">val</span> <span class="py">resizeHeight</span> <span class="p">=</span> <span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">height</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">*</span> <span class="n">ratio</span><span class="p">).</span><span class="n">toInt</span><span class="p">()</span>

        <span class="c1">// 每一帧进行缩放
</span><span class="c1"></span>        <span class="k">val</span> <span class="py">resizeImageFrames</span> <span class="p">=</span> <span class="p">(</span><span class="m">0</span> <span class="n">until</span> <span class="n">frameCount</span><span class="p">).</span><span class="n">mapNotNull</span> <span class="p">{</span>
            <span class="n">gifDecoder</span><span class="p">.</span><span class="n">advance</span><span class="p">()</span>
            <span class="k">var</span> <span class="py">imageFrame</span> <span class="p">=</span> <span class="n">gifDecoder</span><span class="p">.</span><span class="n">nextFrame</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">imageFrame</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">imageFrame</span> <span class="p">=</span> <span class="n">Bitmap</span><span class="p">.</span><span class="n">createScaledBitmap</span><span class="p">(</span><span class="n">imageFrame</span><span class="p">,</span> <span class="n">resizeWidth</span><span class="p">,</span> <span class="n">resizeHeight</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">imageFrame</span>
        <span class="p">}</span>

        <span class="k">val</span> <span class="py">gifEncoder</span> <span class="p">=</span> <span class="n">AnimatedGifEncoder</span><span class="p">()</span>
        <span class="k">var</span> <span class="py">resultData</span><span class="p">:</span> <span class="n">ByteArray</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>

        <span class="k">try</span> <span class="p">{</span>
            <span class="k">val</span> <span class="py">outputStream</span> <span class="p">=</span> <span class="n">ByteArrayOutputStream</span><span class="p">()</span>
            <span class="n">gifEncoder</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">outputStream</span><span class="p">)</span>
            <span class="n">gifEncoder</span><span class="p">.</span><span class="n">setRepeat</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>

            <span class="c1">// 每一帧都进行重新编码
</span><span class="c1"></span>            <span class="n">resizeImageFrames</span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">frameDurations</span><span class="p">).</span><span class="n">forEach</span> <span class="p">{</span>
                <span class="c1">// 设置帧间隔
</span><span class="c1"></span>                <span class="n">gifEncoder</span><span class="p">.</span><span class="n">setDelay</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">)</span>
                <span class="n">gifEncoder</span><span class="p">.</span><span class="n">addFrame</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
                <span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">recycle</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="n">gifEncoder</span><span class="p">.</span><span class="n">finish</span><span class="p">()</span>

            <span class="n">resultData</span> <span class="p">=</span> <span class="n">outputStream</span><span class="p">.</span><span class="n">toByteArray</span><span class="p">()</span>
            <span class="n">outputStream</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">resultData</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">IOException</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="n">printStackTrace</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">resultData</span>
    <span class="p">}</span></code></pre></div>
<h3 id="分辨率压缩">分辨率压缩</h3>

<p>这个是最常用的，而且也比较简单。</p>

<h4 id="ios-4">iOS</h4>

<p>iOS 的 ImageIO 提供了 <code>CGImageSourceCreateThumbnailAtIndex</code> 的 API 来创建缩放的缩略图。在 options 中添加需要缩放的长边参数即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift">    <span class="c1">/// 同步压缩图片数据长边到指定数值</span>
    <span class="c1">///</span>
    <span class="c1">/// - Parameters:</span>
    <span class="c1">///   - rawData: 原始图片数据</span>
    <span class="c1">///   - limitLongWidth: 长边限制</span>
    <span class="c1">/// - Returns: 处理后数据</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">compressImageData</span><span class="p">(</span><span class="kc">_</span> <span class="n">rawData</span><span class="p">:</span><span class="n">Data</span><span class="p">,</span> <span class="n">limitLongWidth</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Data</span><span class="p">?{</span>
        <span class="k">guard</span> <span class="bp">max</span><span class="p">(</span><span class="n">rawData</span><span class="p">.</span><span class="n">imageSize</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">rawData</span><span class="p">.</span><span class="n">imageSize</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limitLongWidth</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">rawData</span>
        <span class="p">}</span>
        
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">imageSource</span> <span class="p">=</span> <span class="n">CGImageSourceCreateWithData</span><span class="p">(</span><span class="n">rawData</span> <span class="k">as</span> <span class="n">CFData</span><span class="p">,</span> <span class="p">[</span><span class="n">kCGImageSourceShouldCache</span><span class="p">:</span> <span class="kc">false</span><span class="p">]</span> <span class="k">as</span> <span class="n">CFDictionary</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">writeData</span> <span class="p">=</span> <span class="n">CFDataCreateMutable</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="kd">let</span> <span class="nv">imageType</span> <span class="p">=</span> <span class="n">CGImageSourceGetType</span><span class="p">(</span><span class="n">imageSource</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        
        
        <span class="kd">let</span> <span class="nv">frameCount</span> <span class="p">=</span> <span class="n">CGImageSourceGetCount</span><span class="p">(</span><span class="n">imageSource</span><span class="p">)</span>
        
        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">imageDestination</span> <span class="p">=</span> <span class="n">CGImageDestinationCreateWithData</span><span class="p">(</span><span class="n">writeData</span><span class="p">,</span> <span class="n">imageType</span><span class="p">,</span> <span class="n">frameCount</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        
        <span class="c1">// 设置缩略图参数，kCGImageSourceThumbnailMaxPixelSize 为生成缩略图的大小。当设置为 800，如果图片本身大于 800*600，则生成后图片大小为 800*600，如果源图片为 700*500，则生成图片为 800*500</span>
        <span class="kd">let</span> <span class="nv">options</span> <span class="p">=</span> <span class="p">[</span><span class="n">kCGImageSourceThumbnailMaxPixelSize</span><span class="p">:</span> <span class="n">limitLongWidth</span><span class="p">,</span> <span class="n">kCGImageSourceCreateThumbnailWithTransform</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span> <span class="n">kCGImageSourceCreateThumbnailFromImageIfAbsent</span><span class="p">:</span><span class="kc">true</span><span class="p">]</span> <span class="k">as</span> <span class="n">CFDictionary</span>
        
        <span class="k">if</span> <span class="n">frameCount</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="c1">// 计算帧的间隔</span>
            <span class="kd">let</span> <span class="nv">frameDurations</span> <span class="p">=</span> <span class="n">imageSource</span><span class="p">.</span><span class="n">frameDurations</span>
            
            <span class="c1">// 每一帧都进行缩放</span>
            <span class="kd">let</span> <span class="nv">resizedImageFrames</span> <span class="p">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="n">frameCount</span><span class="p">).</span><span class="n">compactMap</span><span class="p">{</span> <span class="n">CGImageSourceCreateThumbnailAtIndex</span><span class="p">(</span><span class="n">imageSource</span><span class="p">,</span> <span class="nv">$0</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span> <span class="p">}</span>
            
            <span class="c1">// 每一帧都进行重新编码</span>
            <span class="n">zip</span><span class="p">(</span><span class="n">resizedImageFrames</span><span class="p">,</span> <span class="n">frameDurations</span><span class="p">).</span><span class="n">forEach</span> <span class="p">{</span>
                <span class="c1">// 设置帧间隔</span>
                <span class="kd">let</span> <span class="nv">frameProperties</span> <span class="p">=</span> <span class="p">[</span><span class="n">kCGImagePropertyGIFDictionary</span> <span class="p">:</span> <span class="p">[</span><span class="n">kCGImagePropertyGIFDelayTime</span><span class="p">:</span> <span class="nv">$1</span><span class="p">,</span> <span class="n">kCGImagePropertyGIFUnclampedDelayTime</span><span class="p">:</span> <span class="nv">$1</span><span class="p">]]</span>
                <span class="n">CGImageDestinationAddImage</span><span class="p">(</span><span class="n">imageDestination</span><span class="p">,</span> <span class="nv">$0</span><span class="p">,</span> <span class="n">frameProperties</span> <span class="k">as</span> <span class="n">CFDictionary</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">guard</span> <span class="kd">let</span> <span class="nv">resizedImageFrame</span> <span class="p">=</span> <span class="n">CGImageSourceCreateThumbnailAtIndex</span><span class="p">(</span><span class="n">imageSource</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span>
            <span class="p">}</span>
            <span class="n">CGImageDestinationAddImage</span><span class="p">(</span><span class="n">imageDestination</span><span class="p">,</span> <span class="n">resizedImageFrame</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">guard</span> <span class="n">CGImageDestinationFinalize</span><span class="p">(</span><span class="n">imageDestination</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">writeData</span> <span class="k">as</span> <span class="n">Data</span>
    <span class="p">}</span></code></pre></div>
<h4 id="android-2">Android</h4>

<p>Android 静态图用 Bitmap 里面的 <code>createScaleBitmap</code> API 就好了，GIF 上文已经讲了。</p>
<div class="highlight"><pre class="chroma"><code class="language-kotlin" data-lang="kotlin">   <span class="cm">/**
</span><span class="cm">     * 返回同步压缩图片 Byte 数据 [rawData] 的长边到 [limitLongWidth] 后的 Byte 数据，Gif 目标长边最大压缩到 512，超过用 512
</span><span class="cm">     */</span>
    <span class="k">fun</span> <span class="nf">compressImageDataWithLongWidth</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">rawData</span><span class="p">:</span> <span class="n">ByteArray</span><span class="p">,</span> <span class="n">limitLongWidth</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">ByteArray</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">format</span> <span class="p">=</span> <span class="n">rawData</span><span class="p">.</span><span class="n">imageFormat</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="p">==</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span>
        <span class="p">}</span>

        <span class="k">val</span> <span class="err">(</span><span class="py">imageWidth</span><span class="p">,</span> <span class="n">imageHeight</span><span class="p">)</span> <span class="p">=</span> <span class="n">rawData</span><span class="p">.</span><span class="n">imageSize</span><span class="p">()</span>
        <span class="k">val</span> <span class="py">longSideWidth</span> <span class="p">=</span> <span class="n">max</span><span class="p">(</span><span class="n">imageWidth</span><span class="p">,</span> <span class="n">imageHeight</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">longSideWidth</span> <span class="p">&lt;=</span> <span class="n">limitLongWidth</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">rawData</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="p">==</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">GIF</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 压缩 Gif 分辨率太大编码时容易崩溃
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">compressGifDataWithLongWidth</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">rawData</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="m">512</span><span class="p">,</span> <span class="n">longSideWidth</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">val</span> <span class="py">image</span> <span class="p">=</span> <span class="n">BitmapFactory</span><span class="p">.</span><span class="n">decodeByteArray</span><span class="p">(</span><span class="n">rawData</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">rawData</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
            <span class="k">val</span> <span class="py">ratio</span> <span class="p">=</span> <span class="n">limitLongWidth</span><span class="p">.</span><span class="n">toDouble</span><span class="p">()</span> <span class="p">/</span> <span class="n">longSideWidth</span><span class="p">.</span><span class="n">toDouble</span><span class="p">()</span>
            <span class="k">val</span> <span class="py">resizeImageFrame</span> <span class="p">=</span> <span class="n">Bitmap</span><span class="p">.</span><span class="n">createScaledBitmap</span><span class="p">(</span>
                <span class="n">image</span><span class="p">,</span>
                <span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">width</span><span class="p">.</span><span class="n">toDouble</span><span class="p">()</span> <span class="p">*</span> <span class="n">ratio</span><span class="p">).</span><span class="n">toInt</span><span class="p">(),</span>
                <span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">height</span><span class="p">.</span><span class="n">toDouble</span><span class="p">()</span> <span class="p">*</span> <span class="n">ratio</span><span class="p">).</span><span class="n">toInt</span><span class="p">(),</span>
                <span class="k">true</span>
            <span class="p">)</span>
            <span class="n">image</span><span class="p">.</span><span class="n">recycle</span><span class="p">()</span>
            <span class="k">var</span> <span class="py">resultData</span><span class="p">:</span> <span class="n">ByteArray</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
            <span class="k">when</span> <span class="p">(</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ImageFormat</span><span class="p">.</span><span class="n">PNG</span> <span class="p">-&gt;</span> <span class="p">{</span>
                    <span class="n">resultData</span> <span class="p">=</span> <span class="n">resizeImageFrame</span><span class="p">.</span><span class="n">toByteArray</span><span class="p">(</span><span class="n">Bitmap</span><span class="p">.</span><span class="n">CompressFormat</span><span class="p">.</span><span class="n">PNG</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">ImageFormat</span><span class="p">.</span><span class="n">JPG</span> <span class="p">-&gt;</span> <span class="p">{</span>
                    <span class="n">resultData</span> <span class="p">=</span> <span class="n">resizeImageFrame</span><span class="p">.</span><span class="n">toByteArray</span><span class="p">(</span><span class="n">Bitmap</span><span class="p">.</span><span class="n">CompressFormat</span><span class="p">.</span><span class="n">JPEG</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">-&gt;</span> <span class="p">{</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">resizeImageFrame</span><span class="p">.</span><span class="n">recycle</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">resultData</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></div>
<h2 id="限制大小的压缩方式">限制大小的压缩方式</h2>

<p>也就是将前面讲的方法综合起来，笔者这边给出一种方案，没有对色彩进行改变，JPG 先用二分法减少最多 6 次的压缩系数，GIF 先抽帧，抽帧间隔参考前文，最后采用逼近目标大小缩小分辨率。</p>

<h3 id="ios-5">iOS</h3>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift">    <span class="c1">/// 同步压缩图片到指定文件大小</span>
    <span class="c1">///</span>
    <span class="c1">/// - Parameters:</span>
    <span class="c1">///   - rawData: 原始图片数据</span>
    <span class="c1">///   - limitDataSize: 限制文件大小，单位字节</span>
    <span class="c1">/// - Returns: 处理后数据</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">compressImageData</span><span class="p">(</span><span class="kc">_</span> <span class="n">rawData</span><span class="p">:</span><span class="n">Data</span><span class="p">,</span> <span class="n">limitDataSize</span><span class="p">:</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Data</span><span class="p">?{</span>
        <span class="k">guard</span> <span class="n">rawData</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="n">limitDataSize</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">rawData</span>
        <span class="p">}</span>
        
        <span class="kd">var</span> <span class="nv">resultData</span> <span class="p">=</span> <span class="n">rawData</span>
        
        <span class="c1">// 若是 JPG，先用压缩系数压缩 6 次，二分法</span>
        <span class="k">if</span> <span class="n">resultData</span><span class="p">.</span><span class="n">imageFormat</span> <span class="p">==</span> <span class="p">.</span><span class="n">jpg</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nv">compression</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mi">1</span>
            <span class="kd">var</span> <span class="nv">maxCompression</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mi">1</span>
            <span class="kd">var</span> <span class="nv">minCompression</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="kc">_</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="mi">6</span> <span class="p">{</span>
                <span class="n">compression</span> <span class="p">=</span> <span class="p">(</span><span class="n">maxCompression</span> <span class="o">+</span> <span class="n">minCompression</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="n">compressImageData</span><span class="p">(</span><span class="n">resultData</span><span class="p">,</span> <span class="n">compression</span><span class="p">:</span> <span class="n">compression</span><span class="p">){</span>
                    <span class="n">resultData</span> <span class="p">=</span> <span class="n">data</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kc">nil</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="n">resultData</span><span class="p">.</span><span class="bp">count</span> <span class="o">&lt;</span> <span class="nb">Int</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">(</span><span class="n">limitDataSize</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">minCompression</span> <span class="p">=</span> <span class="n">compression</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">resultData</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="n">limitDataSize</span> <span class="p">{</span>
                    <span class="n">maxCompression</span> <span class="p">=</span> <span class="n">compression</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">resultData</span><span class="p">.</span><span class="bp">count</span> <span class="o">&lt;=</span> <span class="n">limitDataSize</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">resultData</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 若是 GIF，先用抽帧减少大小</span>
        <span class="k">if</span> <span class="n">resultData</span><span class="p">.</span><span class="n">imageFormat</span> <span class="p">==</span> <span class="p">.</span><span class="n">gif</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">sampleCount</span> <span class="p">=</span> <span class="n">resultData</span><span class="p">.</span><span class="n">fitSampleCount</span>
            <span class="k">if</span> <span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="n">compressImageData</span><span class="p">(</span><span class="n">resultData</span><span class="p">,</span> <span class="n">sampleCount</span><span class="p">:</span> <span class="n">sampleCount</span><span class="p">){</span>
                <span class="n">resultData</span> <span class="p">=</span> <span class="n">data</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">resultData</span><span class="p">.</span><span class="bp">count</span> <span class="o">&lt;=</span> <span class="n">limitDataSize</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">resultData</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="kd">var</span> <span class="nv">longSideWidth</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">resultData</span><span class="p">.</span><span class="n">imageSize</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">resultData</span><span class="p">.</span><span class="n">imageSize</span><span class="p">.</span><span class="n">width</span><span class="p">)</span>
        <span class="c1">// 图片尺寸按比率缩小，比率按字节比例逼近</span>
        <span class="k">while</span> <span class="n">resultData</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="n">limitDataSize</span><span class="p">{</span>
            <span class="kd">let</span> <span class="nv">ratio</span> <span class="p">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">(</span><span class="n">limitDataSize</span><span class="p">)</span> <span class="o">/</span> <span class="n">CGFloat</span><span class="p">(</span><span class="n">resultData</span><span class="p">.</span><span class="bp">count</span><span class="p">))</span>
            <span class="n">longSideWidth</span> <span class="o">*=</span> <span class="n">ratio</span>
            <span class="k">if</span> <span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="n">compressImageData</span><span class="p">(</span><span class="n">resultData</span><span class="p">,</span> <span class="n">limitLongWidth</span><span class="p">:</span> <span class="n">longSideWidth</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">resultData</span> <span class="p">=</span> <span class="n">data</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">resultData</span>
    <span class="p">}</span></code></pre></div>
<h3 id="android-3">Android</h3>
<div class="highlight"><pre class="chroma"><code class="language-kotlin" data-lang="kotlin">    <span class="cm">/**
</span><span class="cm">     * 返回同步压缩图片 Byte 数据 [rawData] 的数据大小到 [limitDataSize] 后的 Byte 数据
</span><span class="cm">     */</span>
    <span class="k">fun</span> <span class="nf">compressImageDataWithSize</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">rawData</span><span class="p">:</span> <span class="n">ByteArray</span><span class="p">,</span> <span class="n">limitDataSize</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">ByteArray</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rawData</span><span class="p">.</span><span class="n">size</span> <span class="p">&lt;=</span> <span class="n">limitDataSize</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">rawData</span>
        <span class="p">}</span>

        <span class="k">val</span> <span class="py">format</span> <span class="p">=</span> <span class="n">rawData</span><span class="p">.</span><span class="n">imageFormat</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="p">==</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span>
        <span class="p">}</span>

        <span class="k">var</span> <span class="py">resultData</span> <span class="p">=</span> <span class="n">rawData</span>

        <span class="c1">// 若是 JPG，先用压缩系数压缩 6 次，二分法
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="p">==</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">JPG</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">var</span> <span class="py">compression</span> <span class="p">=</span> <span class="m">100</span>
            <span class="k">var</span> <span class="py">maxCompression</span> <span class="p">=</span> <span class="m">100</span>
            <span class="k">var</span> <span class="py">minCompression</span> <span class="p">=</span> <span class="m">0</span>

            <span class="k">try</span> <span class="p">{</span>
                <span class="k">val</span> <span class="py">outputStream</span> <span class="p">=</span> <span class="n">ByteArrayOutputStream</span><span class="p">()</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="k">in</span> <span class="m">0.</span><span class="p">.</span><span class="m">6</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">compression</span> <span class="p">=</span> <span class="p">(</span><span class="n">maxCompression</span> <span class="p">+</span> <span class="n">minCompression</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span>
                    <span class="n">outputStream</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span>
                    <span class="k">val</span> <span class="py">image</span> <span class="p">=</span> <span class="n">BitmapFactory</span><span class="p">.</span><span class="n">decodeByteArray</span><span class="p">(</span><span class="n">rawData</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">rawData</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
                    <span class="n">image</span><span class="p">.</span><span class="n">compress</span><span class="p">(</span><span class="n">Bitmap</span><span class="p">.</span><span class="n">CompressFormat</span><span class="p">.</span><span class="n">JPEG</span><span class="p">,</span> <span class="n">compression</span><span class="p">,</span> <span class="n">outputStream</span><span class="p">)</span>
                    <span class="n">image</span><span class="p">.</span><span class="n">recycle</span><span class="p">()</span>
                    <span class="n">resultData</span> <span class="p">=</span> <span class="n">outputStream</span><span class="p">.</span><span class="n">toByteArray</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">resultData</span><span class="p">.</span><span class="n">size</span> <span class="p">&lt;</span> <span class="p">(</span><span class="n">limitDataSize</span><span class="p">.</span><span class="n">toDouble</span><span class="p">()</span> <span class="p">*</span> <span class="m">0.9</span><span class="p">).</span><span class="n">toInt</span><span class="p">())</span> <span class="p">{</span>
                        <span class="n">minCompression</span> <span class="p">=</span> <span class="n">compression</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">resultData</span><span class="p">.</span><span class="n">size</span> <span class="p">&gt;</span> <span class="n">limitDataSize</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">maxCompression</span> <span class="p">=</span> <span class="n">compression</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">break</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">outputStream</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">IOException</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">e</span><span class="p">.</span><span class="n">printStackTrace</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">resultData</span><span class="p">.</span><span class="n">size</span> <span class="p">&lt;=</span> <span class="n">limitDataSize</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">resultData</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 若是 GIF，先用抽帧减少大小
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="p">==</span> <span class="n">ImageFormat</span><span class="p">.</span><span class="n">GIF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">val</span> <span class="py">sampleCount</span> <span class="p">=</span> <span class="n">resultData</span><span class="p">.</span><span class="n">fitSampleCount</span><span class="p">()</span>
            <span class="k">val</span> <span class="py">data</span> <span class="p">=</span> <span class="n">compressGifDataWithSampleCount</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">resultData</span><span class="p">,</span> <span class="n">sampleCount</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">data</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">resultData</span> <span class="p">=</span> <span class="k">data</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">null</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">resultData</span><span class="p">.</span><span class="n">size</span> <span class="p">&lt;=</span> <span class="n">limitDataSize</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">resultData</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">val</span> <span class="err">(</span><span class="py">imageWidth</span><span class="p">,</span> <span class="n">imageHeight</span><span class="p">)</span> <span class="p">=</span> <span class="n">resultData</span><span class="p">.</span><span class="n">imageSize</span><span class="p">()</span>
        <span class="k">var</span> <span class="py">longSideWidth</span> <span class="p">=</span> <span class="n">max</span><span class="p">(</span><span class="n">imageWidth</span><span class="p">,</span> <span class="n">imageHeight</span><span class="p">)</span>

        <span class="c1">// 图片尺寸按比率缩小，比率按字节比例逼近
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">resultData</span><span class="p">.</span><span class="n">size</span> <span class="p">&gt;</span> <span class="n">limitDataSize</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">val</span> <span class="py">ratio</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">limitDataSize</span><span class="p">.</span><span class="n">toDouble</span><span class="p">()</span> <span class="p">/</span> <span class="n">resultData</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">toDouble</span><span class="p">())</span>
            <span class="n">longSideWidth</span> <span class="p">=</span> <span class="p">(</span><span class="n">longSideWidth</span><span class="p">.</span><span class="n">toDouble</span><span class="p">()</span> <span class="p">*</span> <span class="n">ratio</span><span class="p">).</span><span class="n">toInt</span><span class="p">()</span>
            <span class="k">val</span> <span class="py">data</span> <span class="p">=</span> <span class="n">compressImageDataWithLongWidth</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">resultData</span><span class="p">,</span> <span class="n">longSideWidth</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">data</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">resultData</span> <span class="p">=</span> <span class="k">data</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">null</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">resultData</span>
    <span class="p">}</span></code></pre></div>
<p>注意在异步线程中使用，毕竟是耗时操作。</p>

<h2 id="最后">最后</h2>

<p>所有代码均封装成文件在 <a href="https://github.com/Nemocdz/ImageCompress-iOS">iOS</a> 和 <a href="https://github.com/Nemocdz/ImageCompress-Android">Android</a> 中了，如有错误和建议，欢迎指出。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
<li><p><a href="https://www.secaibi.com/tools/2013/08/06/%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9-vs-%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9-vs-%E6%8D%9F%E5%A4%9A%E5%B0%91/">无损压缩 vs 有损压缩 vs 损多少</a></p></li>

<li><p><a href="https://www.zhihu.com/question/20028452">图片格式 jpg、png、gif各有什么优缺点？什么情况下用什么格式的图片呢？</a></p></li>

<li><p><a href="https://juejin.im/entry/58fc75e0ac502e0063aa433b">也谈图片压缩</a></p></li>

<li><p><a href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">移动端图片格式调研</a></p></li>

<li><p><a href="https://cloud.tencent.com/developer/article/1004763">浓缩的才是精华：浅析 GIF 格式图片的存储和压缩</a></p></li>

<li><p><a href="https://segmentfault.com/a/1190000000436384">压缩gif的正确姿势</a></p></li>

<li><p><a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/">谈谈 iOS 中图片的解压缩</a></p></li>

<li><p><a href="https://dreampiggy.com/2017/10/30/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88Image:IO%E7%AF%87%EF%BC%89/">iOS平台图片编解码入门教程（Image/IO篇）</a></p></li>
</ul></article>
    <footer class="post-footer">
      
      <p class="post-copyright">
        © 2018 NemocdzThis post was published <strong>188</strong> days ago, content in the post may be inaccurate, even wrong now, please take risk yourself.
      </p>
    </footer>
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-nemocdz-github-io-my-blog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
    
  </section>
  <footer class="site-footer">
  <p>© 2017-2019 Nemocdz&#39;s Blog</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/Nemocdz/hugo-nuo" target="_blank">Nuo</a>.</p>
  
</footer>



<script src="//cdn.bootcss.com/video.js/6.2.1/video.min.js"></script>
<script src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script src="https://nemocdz.github.io/js/bundle.js"></script>




  </body>
</html>
