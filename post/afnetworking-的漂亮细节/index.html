<!DOCTYPE html>
<html lang="zh-cn">
<head>

  <meta charset="utf-8" />

  
  <title>AFNetworking 的漂亮细节</title>

  
  
  <link href="//cdn.jsdelivr.net" rel="dns-prefetch">
  <link href="//cdnjs.cloudflare.com" rel="dns-prefetch">
  
  <link href="//at.alicdn.com" rel="dns-prefetch">
  
  <link href="//fonts.googleapis.com" rel="dns-prefetch">
  <link href="//fonts.gstatic.com" rel="dns-prefetch">
  <link href="///disqus.com" rel="dns-prefetch">
  <link href="//c.disquscdn.com" rel="dns-prefetch">
  
  
  

  

  
  
  <meta name="description" content="最近重读了 AFNetworking 源码，发现很多以前读不懂，也不知道为啥这么写的代码慢慢读懂了。过程中被 AFNetworking 作者的对细节，舒服，整洁的追求所折服。把一些个人觉得写的漂亮的用法总结下来，本文不在于探讨 AFNetworking 源码的具体业余实现，尽量从代码本身和设计角度进行总结（源码解析推荐 AFNetworking 到底做了什么？ 这篇文章）。
">

  
  
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@Nemocdz">
    <meta name="twitter:title" content="AFNetworking 的漂亮细节">
    <meta name="twitter:description" content="最近重读了 AFNetworking 源码，发现很多以前读不懂，也不知道为啥这么写的代码慢慢读懂了。过程中被 AFNetworking 作者的对细节，舒服，整洁的追求所折服。把一些个人觉得写的漂亮的用法总结下来，本文不在于探讨 AFNetworking 源码的具体业余实现，尽量从代码本身和设计角度进行总结（源码解析推荐 AFNetworking 到底做了什么？ 这篇文章）。
">
    <meta name="twitter:image" content="/images/avatar.png">
  

  
  <meta property="og:type" content="article">
  <meta property="og:title" content="AFNetworking 的漂亮细节">
  <meta property="og:description" content="最近重读了 AFNetworking 源码，发现很多以前读不懂，也不知道为啥这么写的代码慢慢读懂了。过程中被 AFNetworking 作者的对细节，舒服，整洁的追求所折服。把一些个人觉得写的漂亮的用法总结下来，本文不在于探讨 AFNetworking 源码的具体业余实现，尽量从代码本身和设计角度进行总结（源码解析推荐 AFNetworking 到底做了什么？ 这篇文章）。
">
  <meta property="og:url" content="https://nemocdz.github.io/post/afnetworking-%E7%9A%84%E6%BC%82%E4%BA%AE%E7%BB%86%E8%8A%82/">
  <meta property="og:image" content="/images/avatar.png">




<meta name="generator" content="Hugo 0.79.1">


<link rel="canonical" href="https://nemocdz.github.io/post/afnetworking-%E7%9A%84%E6%BC%82%E4%BA%AE%E7%BB%86%E8%8A%82/">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">
<meta name="google-site-verification" content="ew6In8Dh7Hjg0Eozgh-VpZHVNe83XRZVOGwQSSAbrfw">
<meta name="msvalidate.01" content="42FB873348345E1A196D7F595FFB7126">
<meta name="baidu-site-verification" content="t6ukG5250x">
<meta name="sogou_site_verification" content="YPqjjJgiSh">
<meta name="360-site-verification" content="699b5919746ff9568f6484fcec29f386">

<meta name="keywords" content="AFNetworking" >

<meta name='description' itemprop="description" content="&lt;p&gt;最近重读了 AFNetworking 源码，发现很多以前读不懂，也不知道为啥这么写的代码慢慢读懂了。过程中被 AFNetworking 作者的对细节，舒服，整洁的追求所折服。把一些个人觉得写的漂">


<meta name="theme-color" content="#02b875">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Nemocdz&#39;s Blog">
<meta name="msapplication-tooltip" content="Nemocdz&#39;s Blog">
<meta name='msapplication-navbutton-color' content="#02b875">
<meta name="msapplication-TileColor" content="#02b875">
<meta name="msapplication-TileImage" content="/icons/icon-144x144.png">
<link rel="icon" href="https://nemocdz.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://nemocdz.github.io/icons/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://nemocdz.github.io/icons/icon-32x32.png">
<link rel="icon" sizes="192x192" href="https://nemocdz.github.io/icons/icon-192x192.png">
<link rel="apple-touch-icon" href="https://nemocdz.github.io/icons/icon-152x152.png">
<link rel="manifest" href="https://nemocdz.github.io/manifest.json">


<link rel="preload" href="https://nemocdz.github.io/styles/main-rendered.min.css" as="style">


<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="https://nemocdz.github.io/images/avatar.png" as="image">
<link rel="preload" href="https://nemocdz.github.io/images/grey-prism.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/images/grey-prism.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="https://nemocdz.github.io/styles/main-rendered.min.css">


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.2/dist/medium-zoom.min.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video-js.min.css">



  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


</head>
  <body>
    <div class="suspension">
      <a role="button" aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden="true"></span></a>
      
        
	<a role="button" aria-label="Go to comments" title="Go to comments" class="to-comment" href="#disqus_thread"><span class="icon icon-comment" aria-hidden="true"></span></a>
        
      
    </div>
    
    
  <header class="site-header">
  <a href="https://nemocdz.github.io"><img class="avatar" src="https://nemocdz.github.io/images/avatar.png" alt="Avatar"></a>
  
  <h2 class="title"><a href="https://nemocdz.github.io">Nemocdz&#39;s Blog</a></h2>
  
  <p class="subtitle">iOS Dev</p>
  <button class="menu-toggle" type="button" aria-label="Main Menu" aria-expanded="false" tab-index="0">
    <span class="icon icon-menu" aria-hidden="true"></span>
  </button>

  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
          
          
           is-active">
          <a href="https://nemocdz.github.io/post">首页</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://nemocdz.github.io/about/">关于</a>
        </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"><li class="social-item">
          <a href="mailto:nemocdz@gmail.com" title="Email" aria-label="Email">
            <span class="icon icon-email" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//github.com/Nemocdz" rel="me" title="GitHub" aria-label="GitHub">
	    <span class="icon icon-github" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//twitter.com/Nemocdz" rel="me" title="Twitter" aria-label="Twitter">
            <span class="icon icon-twitter" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//www.instagram.com/Nemocdz" rel="me" title="Instagram" aria-label="Instagram">
            <span class="icon icon-instagram" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//weibo.com/Nemocdz" rel="me" title="Weibo" aria-label="Weibo">
            <span class="icon icon-weibo" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="https://nemocdz.github.io/images/qrcode.jpg" rel="me" title="Wechat" aria-label="Wechat">
            <span class="icon icon-wechat" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//www.zhihu.com/people/nemocdz" rel="me" title="Zhihu" aria-label="Zhihu">
            <span class="icon icon-zhihu" aria-hidden="true"></span>
          </a>
        </li></ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">AFNetworking 的漂亮细节</h1>
      <p class="post-meta">@Nemocdz · Aug 16, 2017 · 4 min read</p>
    </header>

    
	
	<nav id="TableOfContents">
  <ul>
    <li><a href="#1dispatch_once-方法声明-c-语言变量方法">1.Dispatch_once 方法声明 C 语言变量方法</a></li>
    <li><a href="#2使用反射机制来确定-keypath">2.使用反射机制来确定 KeyPath</a></li>
    <li><a href="#3用-__unused-修饰符修饰不用的-delegate-中的变量">3.用 __unused 修饰符修饰不用的 Delegate 中的变量</a></li>
    <li><a href="#4避开-cocoa-类族的坑">4.避开 Cocoa 类族的坑</a></li>
    <li><a href="#5增加方法到类中再进行-method-swizzling">5.增加方法到类中再进行 Method Swizzling</a></li>
    <li><a href="#6用-gcd-的同步方法来封装代码块">6.用 GCD 的同步方法来封装代码块</a></li>
    <li><a href="#7重写-respondstoselector-更改-delegate-实现的判断依据">7.重写 respondsToSelector 更改 Delegate 实现的判断依据</a></li>
    <li><a href="#8dynamic-关键字实现默认调用父类-settergetter">8.@dynamic 关键字实现默认调用父类 setter&amp;getter</a></li>
    <li><a href="#9kvo-用-context-区分父类与子类">9.KVO 用 Context 区分父类与子类</a></li>
    <li><a href="#10用-gcd-实现同步属性">10.用 GCD 实现同步属性</a></li>
    <li><a href="#11对-nsstream-类的操作">11.对 NSStream 类的操作</a></li>
    <li><a href="#12category-中实现属性懒加载">12.Category 中实现属性懒加载</a></li>
    <li><a href="#13头文件明确声明-nonull-和-nullable">13.头文件明确声明 Nonull 和 Nullable</a></li>
    <li><a href="#最后">最后</a></li>
  </ul>
</nav>

    <article class="post-content"><p>最近重读了 AFNetworking 源码，发现很多以前读不懂，也不知道为啥这么写的代码慢慢读懂了。过程中被 AFNetworking 作者的对细节，舒服，整洁的追求所折服。把一些个人觉得写的漂亮的用法总结下来，本文不在于探讨 AFNetworking 源码的具体业余实现，尽量从代码本身和设计角度进行总结（源码解析推荐 <a href="http://www.jianshu.com/p/856f0e26279d">AFNetworking 到底做了什么？</a> 这篇文章）。</p>
<h2 id="1dispatch_once-方法声明-c-语言变量方法">1.Dispatch_once 方法声明 C 语言变量方法</h2>
<p>感觉很像 OC 的 <code>property</code> 的 getter 方法，一种 C 语言懒加载的感觉，static 修饰符意味只在该编译单元可见（对应 OC 就是 .m 文件），配合单例，只会被执行一次。类似于 <code>if(!object)</code> 的感觉。</p>
<p>如下面例子创建了一个 queue 的方法，调用后返回是同一个变量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">static</span> dispatch_queue_t <span style="color:#50fa7b">url_session_manager_creation_queue</span>() {
    <span style="color:#ff79c6">static</span> dispatch_queue_t af_url_session_manager_creation_queue;
    <span style="color:#ff79c6">static</span> dispatch_once_t onceToken;
    dispatch_once(<span style="color:#ff79c6">&amp;</span>onceToken, <span style="color:#ff79c6">^</span>{
        af_url_session_manager_creation_queue <span style="color:#ff79c6">=</span> dispatch_queue_create(<span style="color:#f1fa8c">&#34;com.alamofire.networking.session.manager.creation&#34;</span>, DISPATCH_QUEUE_SERIAL);
    });

    <span style="color:#ff79c6">return</span> af_url_session_manager_creation_queue;
}
</code></pre></div><h2 id="2使用反射机制来确定-keypath">2.使用反射机制来确定 KeyPath</h2>
<p>在 KVO 中，我们一般会观察通过一个属性，而 <code>@property</code> 其实是一个语法糖，属性=ivar（实例对象）+setter 方法+getter 方法。而 getter 方法名就是属性的名字。利用 OC 中的反射机制 <code>NSStringFromSelector</code> 方法获取属性的 getter 方法的字符串，其实就是属性的 KeyPath。这样的 KeyPath 不容易写错，也容易跳转去看属性的定义。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"> [progress <span style="color:#8be9fd;font-style:italic">addObserver</span>:<span style="color:#8be9fd;font-style:italic">self</span>
            <span style="color:#8be9fd;font-style:italic">forKeyPath</span>:NSStringFromSelector(<span style="color:#ff79c6">@selector</span>(fractionCompleted))
                      <span style="color:#8be9fd;font-style:italic">options</span>:NSKeyValueObservingOptionNew
                      <span style="color:#8be9fd;font-style:italic">context</span>:<span style="color:#8be9fd;font-style:italic">NULL</span>];
</code></pre></div><h2 id="3用-__unused-修饰符修饰不用的-delegate-中的变量">3.用 __unused 修饰符修饰不用的 Delegate 中的变量</h2>
<p>一般协议 delegate 声明时，会把 delegate 弱持有者作为第一个参数传入 delegate 方法中，可是有时候 delegate 的实现者并不关心或不区分 delegate 对象是谁持有的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#8be9fd">void</span>)<span style="color:#50fa7b">URLSession:</span>(__unused NSURLSession <span style="color:#ff79c6">*</span>)<span style="color:#8be9fd;font-style:italic">session</span>
              <span style="color:#50fa7b">task:</span>(NSURLSessionTask <span style="color:#ff79c6">*</span>)<span style="color:#8be9fd;font-style:italic">task</span>
<span style="color:#50fa7b">didCompleteWithError:</span>(NSError <span style="color:#ff79c6">*</span>)<span style="color:#8be9fd;font-style:italic">error</span>{
    <span style="color:#6272a4">//......
</span><span style="color:#6272a4"></span>}
</code></pre></div><h2 id="4避开-cocoa-类族的坑">4.避开 Cocoa 类族的坑</h2>
<p>在 Foudation 框架中，某些类其实是类族，比如 <code>NSArray</code>，生成的某一个 <code>NSArray</code> 对象实际上可能是 <code>NSArray</code> 的子类。所以用 Method Swizzling 的去 Hook 一些系统类方法的时候，要注意某些类实际上是子类，甚至不同系统版本继承链和方法实现都不一样（不一定调用了父类的同名方法）。在 <code>AFURLSessionManager</code> 中为了 Hook 系统的 <code>NSURLSessionTask</code> 的 <code>resume</code> 和 <code>suspend</code> 的方法实现中加上通知。由于 <code>NSURLSessionTask</code> 是一个类族，且 iOS 7 和 iOS 8 上 <code>Task</code> 类的继承链不同，于是有了以下严谨的代码。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#ff79c6">if</span> (NSClassFromString(<span style="color:#f1fa8c">@&#34;NSURLSessionTask&#34;</span>)) {
        NSURLSessionConfiguration <span style="color:#ff79c6">*</span>configuration <span style="color:#ff79c6">=</span> [NSURLSessionConfiguration ephemeralSessionConfiguration];
        NSURLSession <span style="color:#ff79c6">*</span> session <span style="color:#ff79c6">=</span> [NSURLSession <span style="color:#8be9fd;font-style:italic">sessionWithConfiguration</span>:configuration];<span style="color:#6272a4">//先构建 NSURLSession
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#pragma GCC diagnostic push
</span><span style="color:#ff79c6">#pragma GCC diagnostic ignored &#34;-Wnonnull&#34;
</span><span style="color:#ff79c6"></span>        NSURLSessionDataTask <span style="color:#ff79c6">*</span>localDataTask <span style="color:#ff79c6">=</span> [session <span style="color:#8be9fd;font-style:italic">dataTaskWithURL</span>:<span style="color:#8be9fd;font-style:italic">nil</span>];<span style="color:#6272a4">//再通过 session 对象构建一个 task 对象
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#pragma clang diagnostic pop
</span><span style="color:#ff79c6"></span>        <span style="color:#8be9fd">IMP</span> originalAFResumeIMP <span style="color:#ff79c6">=</span> method_getImplementation(class_getInstanceMethod([<span style="color:#8be9fd;font-style:italic">self</span> <span style="color:#ff79c6">class</span>], <span style="color:#ff79c6">@selector</span>(af_resume)));<span style="color:#6272a4">//获取要交换的方法的实现指针
</span><span style="color:#6272a4"></span>        <span style="color:#8be9fd">Class</span> currentClass <span style="color:#ff79c6">=</span> [localDataTask <span style="color:#ff79c6">class</span>];<span style="color:#6272a4">//获取真正的子类
</span><span style="color:#6272a4"></span>        
        <span style="color:#ff79c6">while</span> (class_getInstanceMethod(currentClass, <span style="color:#ff79c6">@selector</span>(resume))) <span style="color:#6272a4">//检查是否实现需要交换的方法
</span><span style="color:#6272a4"></span>        {
            <span style="color:#8be9fd">Class</span> superClass <span style="color:#ff79c6">=</span> [currentClass superclass];
            <span style="color:#8be9fd">IMP</span> classResumeIMP <span style="color:#ff79c6">=</span> method_getImplementation(class_getInstanceMethod(currentClass, <span style="color:#ff79c6">@selector</span>(resume)));<span style="color:#6272a4">//获取实现指针
</span><span style="color:#6272a4"></span>            <span style="color:#8be9fd">IMP</span> superclassResumeIMP <span style="color:#ff79c6">=</span> method_getImplementation(class_getInstanceMethod(superClass, <span style="color:#ff79c6">@selector</span>(resume)));<span style="color:#6272a4">//获取父类的实现指针
</span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">if</span> (classResumeIMP <span style="color:#ff79c6">!=</span> superclassResumeIMP <span style="color:#ff79c6">&amp;&amp;</span>
                originalAFResumeIMP <span style="color:#ff79c6">!=</span> classResumeIMP) {<span style="color:#6272a4">//如果实现和父类不一样且实现不一样
</span><span style="color:#6272a4"></span>                [<span style="color:#8be9fd;font-style:italic">self</span> <span style="color:#8be9fd;font-style:italic">swizzleResumeAndSuspendMethodForClass</span>:currentClass];
            }
            currentClass <span style="color:#ff79c6">=</span> [currentClass superclass];<span style="color:#6272a4">//获取父类继续调用
</span><span style="color:#6272a4"></span>        }
        
        [localDataTask cancel];
        [session finishTasksAndInvalidate];
}
</code></pre></div><h2 id="5增加方法到类中再进行-method-swizzling">5.增加方法到类中再进行 Method Swizzling</h2>
<p>同时为了避免直接换带来多次交换把原来方法弄乱的问题，是先将需要换的方法加到需要替换类中（相当于生成一个副本），然后让那个类里面的副本方法去交换，也就是不影响原来拥有这个方法的类里的方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">+ (<span style="color:#8be9fd">void</span>)<span style="color:#50fa7b">swizzleResumeAndSuspendMethodForClass:</span>(<span style="color:#8be9fd">Class</span>)<span style="color:#8be9fd;font-style:italic">theClass</span> {
    Method afResumeMethod <span style="color:#ff79c6">=</span> class_getInstanceMethod(<span style="color:#8be9fd;font-style:italic">self</span>, <span style="color:#ff79c6">@selector</span>(af_resume));
    Method afSuspendMethod <span style="color:#ff79c6">=</span> class_getInstanceMethod(<span style="color:#8be9fd;font-style:italic">self</span>, <span style="color:#ff79c6">@selector</span>(af_suspend));

    <span style="color:#ff79c6">if</span> (af_addMethod(theClass, <span style="color:#ff79c6">@selector</span>(af_resume), afResumeMethod)) {
        af_swizzleSelector(theClass, <span style="color:#ff79c6">@selector</span>(resume), <span style="color:#ff79c6">@selector</span>(af_resume));
    }

    <span style="color:#ff79c6">if</span> (af_addMethod(theClass, <span style="color:#ff79c6">@selector</span>(af_suspend), afSuspendMethod)) {
        af_swizzleSelector(theClass, <span style="color:#ff79c6">@selector</span>(suspend), <span style="color:#ff79c6">@selector</span>(af_suspend));
    }
}
</code></pre></div><h2 id="6用-gcd-的同步方法来封装代码块">6.用 GCD 的同步方法来封装代码块</h2>
<p>iOS 8 以下 <code>dataTaskWithRequest</code> 是生成的 task 时是并发执行的，造成 taskIdentifer 偶发不唯一，解决办法是使这个方法串行执行，同时用 Dispatch_sync 等待结果返回。调用时封装了一个 C 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"> url_session_manager_create_task_safely(<span style="color:#ff79c6">^</span>{
        downloadTask <span style="color:#ff79c6">=</span> [<span style="color:#8be9fd;font-style:italic">self</span>.session <span style="color:#8be9fd;font-style:italic">downloadTaskWithRequest</span>:request];
  });
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#ff79c6">static</span> dispatch_queue_t <span style="color:#50fa7b">url_session_manager_creation_queue</span>() {
    <span style="color:#ff79c6">static</span> dispatch_queue_t af_url_session_manager_creation_queue;
    <span style="color:#ff79c6">static</span> dispatch_once_t onceToken;
 	<span style="color:#6272a4">//创建一个串行队列，只创建一次
</span><span style="color:#6272a4"></span>    dispatch_once(<span style="color:#ff79c6">&amp;</span>onceToken, <span style="color:#ff79c6">^</span>{
        af_url_session_manager_creation_queue <span style="color:#ff79c6">=</span> dispatch_queue_create(<span style="color:#f1fa8c">&#34;com.alamofire.networking.session.manager.creation&#34;</span>, DISPATCH_QUEUE_SERIAL);
    });
    <span style="color:#ff79c6">return</span> af_url_session_manager_creation_queue;
}

<span style="color:#ff79c6">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">url_session_manager_create_task_safely</span>(dispatch_block_t block) {
    <span style="color:#ff79c6">if</span> (NSFoundationVersionNumber <span style="color:#ff79c6">&lt;</span> NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) {
      	<span style="color:#6272a4">//iOS 8 以下则调用，同步等待结果
</span><span style="color:#6272a4"></span>        dispatch_sync(url_session_manager_creation_queue(), block);
    } <span style="color:#ff79c6">else</span> {
        block();
    }
}
</code></pre></div><h2 id="7重写-respondstoselector-更改-delegate-实现的判断依据">7.重写 respondsToSelector 更改 Delegate 实现的判断依据</h2>
<p>AFNetworking 内部的 <code>AFURLSessionManager</code> 将所有 <code>NSURLSessionDelegate</code> 的方法都接管了并转换成外界 Set 进来的 Block 实现，其中有一些转换并没有做任何处理，单纯转换成 Block。所以是否响应这个 Delegate 方法其实是 block 是否存在，于是内部就重写了 <code>respondsToSelector</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#8be9fd">BOOL</span>)<span style="color:#50fa7b">respondsToSelector:</span>(<span style="color:#8be9fd">SEL</span>)<span style="color:#8be9fd;font-style:italic">selector</span> {
    <span style="color:#ff79c6">if</span> (selector <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">@selector</span>(<span style="color:#8be9fd;font-style:italic">URLSession</span>:<span style="color:#8be9fd;font-style:italic">task</span>:<span style="color:#8be9fd;font-style:italic">willPerformHTTPRedirection</span>:<span style="color:#8be9fd;font-style:italic">newRequest</span>:<span style="color:#8be9fd;font-style:italic">completionHandler</span>:)) {
        <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">self</span>.taskWillPerformHTTPRedirection <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">nil</span>;
    } <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> (selector <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">@selector</span>(<span style="color:#8be9fd;font-style:italic">URLSession</span>:<span style="color:#8be9fd;font-style:italic">dataTask</span>:<span style="color:#8be9fd;font-style:italic">didReceiveResponse</span>:<span style="color:#8be9fd;font-style:italic">completionHandler</span>:)) {
        <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">self</span>.dataTaskDidReceiveResponse <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">nil</span>;
    } <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> (selector <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">@selector</span>(<span style="color:#8be9fd;font-style:italic">URLSession</span>:<span style="color:#8be9fd;font-style:italic">dataTask</span>:<span style="color:#8be9fd;font-style:italic">willCacheResponse</span>:<span style="color:#8be9fd;font-style:italic">completionHandler</span>:)) {
        <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">self</span>.dataTaskWillCacheResponse <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">nil</span>;
    } <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> (selector <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">@selector</span>(<span style="color:#8be9fd;font-style:italic">URLSessionDidFinishEventsForBackgroundURLSession</span>:)) {
        <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">self</span>.didFinishEventsForBackgroundURLSession <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">nil</span>;
    }

    <span style="color:#ff79c6">return</span> [[<span style="color:#8be9fd;font-style:italic">self</span> <span style="color:#ff79c6">class</span>] <span style="color:#8be9fd;font-style:italic">instancesRespondToSelector</span>:selector];
}
</code></pre></div><h2 id="8dynamic-关键字实现默认调用父类-settergetter">8.@dynamic 关键字实现默认调用父类 setter&amp;getter</h2>
<p>当子类重新声明一个父类的属性时，其实默认合成了 setter&amp;getter 并覆盖了父类的默认实现。对于想子类声明属性却希望默认调用父类属性的 setter&amp;getter，可以用 <code>@dynamic</code> 关键字。</p>
<p><code>AFHTTPSessionManger</code> 是 <code>AFURLSessionManger</code> 的子类，也声明了 securityPolicy 属性并重写其 setter 方法，但希望 getter 方法调用父类的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#ff79c6">@dynamic</span> securityPolicy;

- (<span style="color:#8be9fd">void</span>)<span style="color:#50fa7b">setSecurityPolicy:</span>(AFSecurityPolicy <span style="color:#ff79c6">*</span>)<span style="color:#8be9fd;font-style:italic">securityPolicy</span> {
    <span style="color:#ff79c6">if</span> (securityPolicy.SSLPinningMode <span style="color:#ff79c6">!=</span> AFSSLPinningModeNone <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>[<span style="color:#8be9fd;font-style:italic">self</span>.baseURL.scheme <span style="color:#8be9fd;font-style:italic">isEqualToString</span>:<span style="color:#f1fa8c">@&#34;https&#34;</span>]) {
        NSString <span style="color:#ff79c6">*</span>pinningMode <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">@&#34;Unknown Pinning Mode&#34;</span>;
        <span style="color:#ff79c6">switch</span> (securityPolicy.SSLPinningMode) {
            <span style="color:#ff79c6">case</span> <span style="color:#8be9fd;font-style:italic">AFSSLPinningModeNone</span>:        pinningMode <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">@&#34;AFSSLPinningModeNone&#34;</span>; <span style="color:#ff79c6">break</span>;
            <span style="color:#ff79c6">case</span> <span style="color:#8be9fd;font-style:italic">AFSSLPinningModeCertificate</span>: pinningMode <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">@&#34;AFSSLPinningModeCertificate&#34;</span>; <span style="color:#ff79c6">break</span>;
            <span style="color:#ff79c6">case</span> <span style="color:#8be9fd;font-style:italic">AFSSLPinningModePublicKey</span>:   pinningMode <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">@&#34;AFSSLPinningModePublicKey&#34;</span>; <span style="color:#ff79c6">break</span>;
        }
        NSString <span style="color:#ff79c6">*</span>reason <span style="color:#ff79c6">=</span> [NSString <span style="color:#8be9fd;font-style:italic">stringWithFormat</span>:<span style="color:#f1fa8c">@&#34;A security policy configured with `%@` can only be applied on a manager with a secure base URL (i.e. https)&#34;</span>, pinningMode];
        <span style="color:#ff79c6">@throw</span> [NSException <span style="color:#8be9fd;font-style:italic">exceptionWithName</span>:<span style="color:#f1fa8c">@&#34;Invalid Security Policy&#34;</span> <span style="color:#8be9fd;font-style:italic">reason</span>:reason <span style="color:#8be9fd;font-style:italic">userInfo</span>:<span style="color:#8be9fd;font-style:italic">nil</span>];
    }
    [<span style="color:#8be9fd;font-style:italic">super</span> <span style="color:#8be9fd;font-style:italic">setSecurityPolicy</span>:securityPolicy];
}
</code></pre></div><h2 id="9kvo-用-context-区分父类与子类">9.KVO 用 Context 区分父类与子类</h2>
<p>KVO 中的 API <code>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context</code> 总是在 dealloc 方法中配合 <code>- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context</code> 成对使用来移除观察者。但如果父类和子类都同时观察一个 keyPath，那么容易导致 addObserver 和 removeObserver 的个数不匹配（子类未调用父类的 addObserver 方法但调用了父类的 dealloc），导致重复调用 remove 同一个 keyPath 而 Crash。所以加上 context 作为类别唯一标识才是比较安全的做法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#8be9fd">void</span>)<span style="color:#50fa7b">dealloc</span> {
    <span style="color:#ff79c6">for</span> (NSString <span style="color:#ff79c6">*</span>keyPath <span style="color:#ff79c6">in</span> AFHTTPRequestSerializerObservedKeyPaths()) {
        <span style="color:#ff79c6">if</span> ([<span style="color:#8be9fd;font-style:italic">self</span> <span style="color:#8be9fd;font-style:italic">respondsToSelector</span>:NSSelectorFromString(keyPath)]) {
            [<span style="color:#8be9fd;font-style:italic">self</span> <span style="color:#8be9fd;font-style:italic">removeObserver</span>:<span style="color:#8be9fd;font-style:italic">self</span> <span style="color:#8be9fd;font-style:italic">forKeyPath</span>:keyPath <span style="color:#8be9fd;font-style:italic">context</span>:AFHTTPRequestSerializerObserverContext];
        }
    }
}
</code></pre></div><h2 id="10用-gcd-实现同步属性">10.用 GCD 实现同步属性</h2>
<p>实现某个属性值 setter 方法和 getter 方法的同步除了用 <code>NSLock</code> 或者 <code>@synchronized</code> 关键字加锁外，可以使用在并发队列里 setter 配合 <code>dispatch_barrier_async</code> 加上 getter 配合 dispatch_sync 实现。这样读取是同步并发的，写入是在没有读取都完成后，同步执行的，并且性能比加锁更好。<code>AFHTTPRequestSerializer</code> 里的 <code>HTTPHeaderField</code> 就是这样的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#8be9fd">void</span>)<span style="color:#50fa7b">setValue:</span>(NSString <span style="color:#ff79c6">*</span>)<span style="color:#8be9fd;font-style:italic">value</span>
<span style="color:#50fa7b">forHTTPHeaderField:</span>(NSString <span style="color:#ff79c6">*</span>)<span style="color:#8be9fd;font-style:italic">field</span>
{
    dispatch_barrier_async(<span style="color:#8be9fd;font-style:italic">self</span>.requestHeaderModificationQueue, <span style="color:#ff79c6">^</span>{
        [<span style="color:#8be9fd;font-style:italic">self</span>.mutableHTTPRequestHeaders <span style="color:#8be9fd;font-style:italic">setValue</span>:value <span style="color:#8be9fd;font-style:italic">forKey</span>:field];
    });
}

- (NSString <span style="color:#ff79c6">*</span>)<span style="color:#50fa7b">valueForHTTPHeaderField:</span>(NSString <span style="color:#ff79c6">*</span>)<span style="color:#8be9fd;font-style:italic">field</span> {
    NSString <span style="color:#ff79c6">__block</span> <span style="color:#ff79c6">*</span>value;
    dispatch_sync(<span style="color:#8be9fd;font-style:italic">self</span>.requestHeaderModificationQueue, <span style="color:#ff79c6">^</span>{
        value <span style="color:#ff79c6">=</span> [<span style="color:#8be9fd;font-style:italic">self</span>.mutableHTTPRequestHeaders <span style="color:#8be9fd;font-style:italic">valueForKey</span>:field];
    });
    <span style="color:#ff79c6">return</span> value;
}
</code></pre></div><h2 id="11对-nsstream-类的操作">11.对 NSStream 类的操作</h2>
<p><code>AFHTTPRequestSerizlizer</code> 进行 Multipart 协议支持时，使用了 <code>NSStream</code> 对象。</p>
<p>一般使用方法是</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#6272a4">//创建流对象
</span><span style="color:#6272a4"></span>NSInputStream <span style="color:#ff79c6">*</span>stream <span style="color:#ff79c6">=</span> [[NSInputStream alloc] <span style="color:#8be9fd;font-style:italic">initWithData</span>:[NSData data]];

<span style="color:#6272a4">//放入 Runloop 中
</span><span style="color:#6272a4"></span>[stream <span style="color:#8be9fd;font-style:italic">scheduleInRunLoop</span>:NSRunLoop.currentRunLoop <span style="color:#8be9fd;font-style:italic">forMode</span>:NSDefaultRunLoopMode];

<span style="color:#6272a4">//打开流
</span><span style="color:#6272a4"></span>[stream open];

<span style="color:#6272a4">//.......
</span><span style="color:#6272a4"></span>
<span style="color:#6272a4">//从 Runloop 中移除
</span><span style="color:#6272a4"></span>[stream <span style="color:#8be9fd;font-style:italic">removeFromRunLoop</span>:NSRunLoop.currentRunLoop <span style="color:#8be9fd;font-style:italic">forMode</span>:NSDefaultRunLoopMode];

<span style="color:#6272a4">//关闭流
</span><span style="color:#6272a4"></span>[stream close];
</code></pre></div><p>结果发现 AFNetworking 在析构 <code>NSStream</code> 时，没有调用 removeFromRunLoop，仅仅调用了 close，我一开始还以为漏了，结果后来书写 Demo 验证发现其引用计数的变化时如下的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#6272a4">//放入 Runloop 中-----引用计数 +2
</span><span style="color:#6272a4"></span>[stream <span style="color:#8be9fd;font-style:italic">scheduleInRunLoop</span>:NSRunLoop.currentRunLoop <span style="color:#8be9fd;font-style:italic">forMode</span>:NSDefaultRunLoopMode];

<span style="color:#6272a4">//打开流-----引用计数不变
</span><span style="color:#6272a4"></span>[stream open];

<span style="color:#6272a4">//.......
</span><span style="color:#6272a4"></span>
<span style="color:#6272a4">//从 Runloop 中移除-----引用计数 -2
</span><span style="color:#6272a4"></span>[stream <span style="color:#8be9fd;font-style:italic">removeFromRunLoop</span>:NSRunLoop.currentRunLoop <span style="color:#8be9fd;font-style:italic">forMode</span>:NSDefaultRunLoopMode];

<span style="color:#6272a4">//关闭流-----引用计数 -2
</span><span style="color:#6272a4"></span>[stream close];
</code></pre></div><p>也就是说 <code>open</code> 和 <code>close</code> 对引用计数的影响不是一对的，从一定程度上解释只调用 <code>close</code> 也可以达到 <code>removeFromRunLoop</code> 的原因，个人猜测 <code>close</code> 和 <code>removeFromRunLoop</code> 调用任意一个都可以。顺便提一句 <code>AFMultipartBodyStream</code> 还对 <code>NSStreamStauts</code> 一些只读属性改成读写的，并自定义了所有流的方法。</p>
<h2 id="12category-中实现属性懒加载">12.Category 中实现属性懒加载</h2>
<p>使用了 OC 的关联对象，先获取判断是否为空，不然就生成并关联上。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (AFRefreshControlNotificationObserver <span style="color:#ff79c6">*</span>)<span style="color:#50fa7b">af_notificationObserver</span> {
    AFRefreshControlNotificationObserver <span style="color:#ff79c6">*</span>notificationObserver <span style="color:#ff79c6">=</span> objc_getAssociatedObject(<span style="color:#8be9fd;font-style:italic">self</span>, <span style="color:#ff79c6">@selector</span>(af_notificationObserver));
    <span style="color:#ff79c6">if</span> (notificationObserver <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">nil</span>) {
        notificationObserver <span style="color:#ff79c6">=</span> [[AFRefreshControlNotificationObserver alloc] <span style="color:#8be9fd;font-style:italic">initWithActivityRefreshControl</span>:<span style="color:#8be9fd;font-style:italic">self</span>];
        objc_setAssociatedObject(<span style="color:#8be9fd;font-style:italic">self</span>, <span style="color:#ff79c6">@selector</span>(af_notificationObserver), notificationObserver, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    <span style="color:#ff79c6">return</span> notificationObserver;
}
</code></pre></div><h2 id="13头文件明确声明-nonull-和-nullable">13.头文件明确声明 Nonull 和 Nullable</h2>
<p>自从支持 Swift 后，和 Swift 中的 ? 和 ! 对应，OC 引入了 <code>Nonull</code> 和 <code>Nullable</code> 关键字，当然对每个方法参数和属性声明关键字是很大工作量的，这时我们可以用一对系统宏包含在最前和最后，中间的默认关键字就是 <code>Nonull</code> 了，这时候针对 <code>Nullable</code> 的参数或属性进行补充就可以了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#6272a4">//.h
</span><span style="color:#6272a4"></span>NS_ASSUME_NONNULL_BEGIN

<span style="color:#6272a4">//...
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">@property</span> (<span style="color:#ff79c6">nonatomic</span>, <span style="color:#ff79c6">strong</span>, nullable) <span style="color:#8be9fd">id</span> <span style="color:#ff79c6">&lt;</span>AFImageRequestCache<span style="color:#ff79c6">&gt;</span> imageCache;
<span style="color:#6272a4">//...
</span><span style="color:#6272a4"></span>
NS_ASSUME_NONNULL_END
</code></pre></div><h2 id="最后">最后</h2>
<p>AFNetworking 是一份写得十分严谨漂亮的源码，其中对 KVO&amp;KVC，GCD，Block，关联对象的运用十分巧妙且准确，同时接口的封装，代码的划分也很恰当。阅读之后对于代码规范又有了新的理解。</p></article>
    <footer class="post-footer">
      
      <p class="post-copyright">
        © Nemocdz. This post was published <strong>1397</strong> days ago, content in the post may be inaccurate, even wrong now, please take risk yourself.
      </p>
    </footer>
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-nemocdz-github-io-my-blog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
    
  </section>
  
<footer class="site-footer">
  <p>© 2017-2021 Nemocdz&#39;s Blog</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> with theme <a href="https://github.com/Nemocdz/hugo-nuo" target="_blank" rel="noopener">Nuo</a>.</p>
  
</footer>


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js"></script>



<script async src="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video.min.js"></script>




<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    },
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>



<script src="https://nemocdz.github.io/scripts/index.min.js"></script>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('\/service-worker.js').then(function() {
      console.log('[ServiceWorker] Registered');
    });
  }
</script>








  </body>
</html>
